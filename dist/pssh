#!/usr/bin/env php
<?php
##################################################
# Config
##################################################
define('ERRORS', false);
define('PACKAGED', true);

// Note: leave this for packaging ?>
<?php

/**
 * Color constants
 *  - https://en.wikipedia.org/wiki/ANSI_escape_code
 */
class CONSOLE_COLORS
{
    public static $foreground = [
        'black' => '0;30',
        'dark_gray' => '1;30',
        'blue' => '0;34',
        'light_blue' => '1;34',
        'green' => '0;32',
        'light_green' => '1;32',
        'cyan' => '0;36',
        'light_cyan' => '1;36',
        'red' => '0;31',
        'light_red' => '1;31',
        'purple' => '0;35',
        'light_purple' => '1;35',
        'brown' => '0;33',
        'yellow' => '1;33',
        'light_gray' => '0;37',
        'white' => '1;37',
    ];

    public static $background = [
        'black' => '40',
        'red' => '41',
        'green' => '42',
        'yellow' => '43',
        'blue' => '44',
        'magenta' => '45',
        'cyan' => '46',
        'light_gray' => '47',
    ];

    public static $other = [
        'bold' => '1',
        'dim' => '2',
        'underline' => '4',
        'blink' => '5',
        'inverse' => '7',

        // Don't seem to work for the author at least:
        //'italic' => '3',
        //'blink_fast' => '6',
        //'concealed' => '8',
        //'strike' => '9',
        //'double_underline' => '21',
        //'frame' => '51',
        //'encircled' => '52',
        //'overlined' => '53',
    ];
}

// Note: leave this for packaging ?>
<?php
/**
 * Command abstract
 *  - primary or subcommand structure
 *  - main "run" method accepts and parses arguments
 *  - default run method checks for available sub-methods
 */
class Command
{

    /**
     * Callable Methods
     */
    protected static $METHODS = [
        'clear',
        'exit',
        'help',
        'prompt',
    ];

    /**
     * Method aliases
     */
    protected static $METHOD_ALIASES = [
        'h' => 'help',
        '?' => 'help',
        'p' => 'prompt',
        'x' => 'exit',
        'q' => 'exit',
        'quit' => 'exit',
    ];

    /**
     * Default method if none specified
     */
    protected static $DEFAULT_METHOD="prompt";

    /**
     * Methods that are OK to run as root without warning
     */
    protected static $ROOT_METHODS = [];

    /**
     * Config options that are hidden from help output
     * - Add config values here that would not typically be overridden by a flag
     * - Cleans up help output and avoids confusion
     */
    protected static $HIDDEN_CONFIG_OPTIONS = [];

    /**
     * Main Tool instance
     */
    protected $main_tool;

    /**
     * Constructor
     */
    public function __construct($main_tool)
    {
        $this->setMainTool($main_tool);
    }

    /**
     * Set Main Tool
     * - for shared functionality
     */
    public function setMainTool($main_tool)
    {
        $this->main_tool = $main_tool;
    }

    /**
     * Run - parse args and run method specified
     */
    public function try_calling($arg_list, $initial=false, $prompt_when_done=false)
    {
        $this->log($arg_list);

        $method = array_shift($arg_list);

        $class = get_class($this);

        if (empty($method))
        {
            $method = static::$DEFAULT_METHOD;
        }

        $aliases = static::getMergedProperty('METHOD_ALIASES');
        if (isset($aliases[$method]))
        {
            $method = $aliases[$method];
        }

        $this->method = $method;

        try
        {
            $valid_methods = static::getMergedProperty('METHODS');

            if (!in_array($method, $valid_methods))
            {
                if ($prompt_when_done)
                {
                    $this->warn("Invalid method - $method");
                    $this->prompt(false, true);
                }
                else
                {
                    $this->help();
                    $this->hr();
                    $this->error("Invalid method - $method");
                }
            }

            $args = [];
            foreach ($arg_list as $_arg)
            {
                if (strpos($_arg, '--') === 0)
                {
                    $arg = substr($_arg,2);
                    $arg_split = explode("=",$arg,2);

                    if (!isset($arg_split[1]))
                    {
                        $arg_split[1] = true;
                    }

                    $this->main_tool->configure($arg_split[0], $arg_split[1]);
                }
                else
                {
                    $args[]= $_arg;
                }
            }

            // Check if running as root - if so, make sure that's OK
            if ($this->main_tool->running_as_root and !$this->main_tool->allow_root)
            {
                $root_methods = static::getMergedProperty('ROOT_METHODS');
                if (!in_array($method, $root_methods))
                {
                    $this->error("Cowardly refusing to run as root. Use --allow-root to bypass this error.", 200);
                }
            }

            if ($initial)
            {
                date_default_timezone_set($this->main_tool->timezone);

                $this->checkRequirements();

                $this->log('Determined home directory to be ' . $this->main_tool->home_dir);


                // Run an update check
                if ($this->updateCheck(true, true)) // auto:true, output:true
                {
                    if ($method != 'update')
                    {
                        $this->sleep(3);
                    }
                }
            }

            $call_info = "$class->$method(" . implode(",", $args) . ")";
            $this->log("Calling $call_info");
            $this->hrl();

            try {
                call_user_func_array([$this, $method], $args);
            } catch (ArgumentCountError $e) {
                $this->_run_error($e, $method);
            } catch (InvalidArgumentException $e) {
                $this->_run_error($e, $method);
            } catch (Exception $e) {
                $this->_run_error($e, $method);
            }

            $this->hrl();
            $this->log("$call_info complete");

        } catch (Exception $e) {
            $this->error($e->getMessage());
        }

        if ($prompt_when_done) $this->prompt(false, false);
    }
        protected function _run_error($e, $method)
        {
            $error = (get_class($e) == 'Exception') ? $e->getMessage() : "Incorrect usage - see method help below:";
            $this->error($error, false);
            $this->help($method);
            exit(500);
        }

    protected $___clear = [
        "Clear the screen",
    ];
    public function clear()
    {
        $this->main_tool->clear();
    }

    protected $___exit = [
        "Exit the command prompt",
    ];
    public function exit()
    {
        exit();
    }

    protected $___help = [
        "Shows help/usage information.",
        ["Method/option for specific help", "string"],
    ];
    public function help($specific=false)
    {
        // Specific help?
        if ($specific) return $this->_help_specific($specific);

        $methods = static::getMergedProperty('METHODS');
        sort($methods);

        $this->version();

        $this->output("\nUSAGE:\n");

        $this->output(static::SHORTNAME." <method> (argument1) (argument2) ... [options]\n");

        $this->hr('-');
        $this->output3col("METHOD", "INFO");
        $this->hr('-');

        foreach($methods as $method)
        {
            $string = "";
            $help_text = "";
            $help = $this->_help_var($method, 'method');
            $help_text = empty($help) ? "" : array_shift($help);
            $this->output3col($method, $help_text);
        }

        $this->hr('-');
        $this->output("To get more help for a specific method:  ".static::SHORTNAME." help <method>");

        $this->output("");
        $this->hr('-');
        $this->output3col("OPTION", "TYPE", "INFO");
        $this->hr('-');

        $hidden_options = static::getMergedProperty('HIDDEN_CONFIG_OPTIONS');

        foreach ($this->getPublicProperties() as $property)
        {
            if (!$this->verbose and in_array($property, $hidden_options)) continue;
            $property = str_replace('_', '-', $property);
            $help = $this->_help_var($property, 'option');
            $type = "";
            $info = "";
            if ($help)
            {
                $help = $this->_help_param($help);
                $type = "($help[1])";
                $info = $help[0];
            }
            $this->output3col("--$property", $type, $info);
        }
        $this->hr('-');
        $this->output("Use no- to set boolean option to false - eg. --no-stamp-lines");
        if (!$this->verbose)
        {
            $this->output($this->colorize("Less common options are hidden.  Use --verbose to show ALL options.", "yellow"));
        }
    }

    protected $___prompt = [
        "Show interactive prompt"
    ];
    public function prompt($clear=false, $help=true)
    {
        if ($clear) $this->clear();

        if ($help)
        {
            $this->hr();
            $this->output("Enter 'help' to list valid commands");
        }

        $this->hr();
        $command_string = $this->input("cmd");
        $arg_list = explode(" ", $command_string);

        $this->try_calling($arg_list, false, true);
    }

        /**
        * Show help for a specific method or option
        */
        protected function _help_specific($specific)
        {
            $help = $this->_help_var($specific);
            if (empty($help))
            {
                $this->error("No help found for '$specific'");
            }

            $specific = str_replace('-', '_', $specific);

            if (is_callable([$this, $specific]))
            {
                // Method Usage
                $help_text = array_shift($help);

                $usage = static::SHORTNAME." $specific";
                $params = $this->_getMethodParams($specific);
                foreach ($params as $p => $param)
                {
                    $help_param = $this->_help_param($help[$p]);

                    $param = $help_param['string']
                        ? "\"$param\""
                        : $param;

                    $param = $help_param['optional']
                        ? "($param)"
                        : $param;

                    $usage.= " $param";
                }

                $usage.= " [options]";

                $this->output("USAGE:\n");
                $this->output("$usage\n");

                $this->hr('-');
                $this->output3col("METHOD", "INFO");
                $this->hr('-');
                $this->output3col($specific, $help_text);
                $this->hr('-');
                $this->br();

                if (!empty($params))
                {
                    $this->output3col("PARAMETER", "TYPE", "INFO");
                    $this->hr('-');
                    $this->hr('-');
                    foreach ($params as $p => $param)
                    {
                        $help_param = $this->_help_param($help[$p]);
                        $output = $help_param['optional'] ? "" : "*";
                        $output.= $param;
                        $this->output3col($output, "($help_param[1])", $help_param[0]);
                    }
                    $this->hr('-');
                    $this->output("* Required parameter");
                }
            }
            else if (isset($this->$specific))
            {
                // Option info
                $help_param = $this->_help_param($help);
                $specific = str_replace('_', '-', $specific);

                $this->hr('-');
                $this->output3col("OPTION", "(TYPE)", "INFO");
                $this->hr('-');
                $this->output3col("--$specific", "($help_param[1])", $help_param[0]);
                $this->hr('-');
            }
        }

        /**
        * Get help var for specific method or option
        */
        protected function _help_var($specific, $type=false)
        {
            $help = false;
            $specific = str_replace('-', '_', $specific);

            if ($type == 'method' or empty($type))
            {
                $help_var = "___" . $specific;
            }

            if ($type == 'option' or (empty($type) and empty($this->$help_var)))
            {
                $help_var = "__" . $specific;
            }

            if (!empty($this->$help_var))
            {
                $help = $this->$help_var;
                if (!is_array($help))
                {
                    $help = [$help];
                }
            }
            return $help;
        }

        /**
         * Clean help param - fill in defaults
         */
        protected function _help_param ($param)
        {
            if (!is_array($param))
            {
                $param = [$param];
            }

            if (empty($param[1]))
            {
                $param[1] = "boolean";
            }

            if (empty($param[2]))
            {
                $param[2] = "optional";
            }

            $param['optional'] = ($param[2] == 'optional');
            $param['required'] = !$param['optional'];

            $param['string'] = ($param[1] == 'string');

            return $param;
        }

    /**
     * Get static property by merging up with partent values
     */
    protected static function getMergedProperty($property)
    {
        $value = [];
        $class = get_called_class();
        while ($class and class_exists($class))
        {
            if (isset($class::$$property))
            {
                $value = array_merge($value, $class::$$property);
                $class = get_parent_class($class);
            }
        }
        return array_unique($value);
    }

    /**
     * Merge arrays recursively, in the way we expect
     * Primarily, we are expecting meaningful keys - eg. option arrays, commands/subcommands, etc.
     *  - Start with array1
     *  - Check each key - if that key exists in array2, overwrite with array2's value, EXCEPT:
     *  - If both values are an array, merge the values instead - recursively
     *  - Last, add keys that are in array2 only
     */
    protected function mergeArraysRecursively($array1, $array2)
    {
        $merged_array = [];
        foreach ($array1 as $key => $value1)
        {
            if (isset($array2[$key]))
            {
                if (is_array($array1[$key]) and is_array($array2[$key]))
                {
                    $merged_array[$key] = $this->mergeArraysRecursively($array1[$key], $array2[$key]);
                }
                else
                {
                    $merged_array[$key] = $array2[$key];
                    unset($array2[$key]);
                }
            }
            else
            {
                $merged_array[$key] = $value1;
            }
        }
        foreach ($array2 as $key => $value2)
        {
            $merged_array[$key] = $value2;
        }

        return $merged_array;
    }

    /**
     * Magic handling for subcommands to call main command methods
     */
    public function __call($method, $arguments)
    {
        $callable = [$this->main_tool, $method];
        if (is_callable($callable))
        {
            return call_user_func_array ($callable, $arguments);
        }

        throw new Exception("Invalid class method '$method'");
    }

}

// Note: leave this for packaging ?>
<?php
/**
 * Visual Command type
 *  - Think visual mode in vim
 *  - single letter commands, or sequences thereof
 */
class Command_Visual extends Command
{
    public $commands = [];

    public $reload_function;
    public $reload_data;

    /**
     * Constructor
     */
    public function __construct($main_tool, $options=[])
    {
        parent::__construct($main_tool);

        if (empty($options['reload_function']) or !is_callable($options['reload_function']))
        {
            $this->error("Option 'reload_function' is required");
        }

        $this->reload_function = $options['reload_function'];
        if (isset($options['reload_data']))
        {
            $this->reload_data = $options['reload_data'];
        }

        $this->commands = [
            'help' => [
                'description' => 'Help - list available commands',
                'keys' => '?',
                'callback' => [$this, 'help'],
            ],
            'reload' => [
                'description' => 'Reload - refresh list',
                'keys' => 'r',
                'callback' => [$this, 'reload'],
            ],
            'quit' => [
                'description' => 'Quit - exit the list',
                'keys' => 'q',
                'callback' => [$this, 'quit'],
            ],
        ];
        if (isset($options['commands']))
        {
            $this->commands = $this->mergeArraysRecursively($this->commands, $options['commands']);
        }
        $this->cleanCommandArray($this->commands);
    }

    /**
     * Clean an array of commands
     *  - Make sure keys are set properly as array of single keys
     */
    protected function cleanCommandArray(&$commands)
    {
        foreach ($commands as $command_slug => $command_details)
        {
            if (is_string($command_details['keys'])) $command_details['keys'] = str_split($command_details['keys']);
            if (!is_array($command_details['keys'])) $this->error("Invalid command keys for '$command_slug'");

            if (
                isset($command_details['callback'])
                and is_array($command_details['callback'])
                and isset($command_details['callback']['subcommands'])
            ) {
                $this->cleanCommandArray($command_details['callback']['subcommands']);
            }

            $commands[$command_slug] = $command_details;
        }
    }

    /**
     * Prompt for input and run the associated command if valid
     * @param $commmands - the commands to select from
     * @return boolean whether command was valid or not
     */
    protected function promptAndRunCommand($commands, $show_options=false)
    {
        if (!is_array($commands) or empty($commands))
        {
            $this->error("Invalid commands passed - expecting array of command definitions");
        }

        if ($show_options)
        {
            foreach ($commands as $key => $details)
            {
                $name = $details['description'];
                $keys = $details['keys'];
                $this->output( str_pad( implode( ",", $keys) . " ", 15, ".") . " " . $name );
            }
        }

        $input = $this->input(true, null, false, 'single', 'hide_input');
        $matched = false;

        foreach ($commands as $command_slug => $command_details)
        {
            $command_name = $command_details['description'];
            $command_keys = $command_details['keys'];
            $command_callable = $command_details['callback'];

            if (in_array($input, $command_keys))
            {
                $matched = true;

                if ( ! is_callable($command_callable))
                {
                    if (is_array($command_callable))
                    {
                        if (isset($command_callable['subcommands']))
                        {
                            while (true)
                            {
                                $this->clear();
                                $this->hr();
                                $this->output("$command_name:");
                                $this->hr();
                                $continue_loop = $this->promptAndRunCommand($command_callable['subcommands'], true);

                                if (
                                    $continue_loop === false
                                    or (isset($command_details['continue']) and $command_details['continue'] === false)
                                ) {
                                    return;
                                }
                            }
                        }
                    }

                    $this->error("Uncallable method for $input", false, true);
                    return true;
                }

                $continue_loop = call_user_func($command_callable, $this);

                // Reload if set
                if (!empty($command_details['reload']))
                {
                    $this->reload();
                }

                if (
                    $continue_loop === false
                    or (isset($command_details['continue']) and $command_details['continue'] === false)
                ) {
                    return false;
                }

                return true;
            }
        }

        if (!$matched)
        {
            $this->log("Invalid input $input");
        }
    }

    /**
     * Built-in commands
     */

    // Help
    public function help($specific=false)
    {
        $this->clear();
        $this->hr();
        $this->output("Available Commands:");
        $this->hr();
        foreach ($this->commands as $command_slug => $command_details)
        {
            $command_name = $command_details['description'];
            $command_keys = $command_details['keys'];
            $this->output( str_pad( implode( ",", $command_keys) . " ", 15, ".") . " " . $command_name );
        }
        $this->hr();
        $this->input("Hit any key to exit help", null, false, true);
    }

    // Quit
    public function quit()
    {
        return false; // Back to previous area, basically
    }

    // Reload
    public function reload()
    {
        return call_user_func($this->reload_function, $this->reload_data, $this);
    }
}

// Note: leave this for packaging ?>
<?php
/**
 * Visual command that shows a list of items
 */
class Command_Visual_List extends Command_Visual
{
    public $list=[];
    public $list_original=[];
    public $list_selection=[];

    public $focus=0;
    public $starting_line=1;
    public $page_info=[];

    public $multiselect = false;
    public $template = "{_KEY}: {_VALUE}";

    /**
     * Constructor
     */
    public function __construct($main_tool, $list, $options=[])
    {
        $this->setMainTool($main_tool);

        if (empty($list))
        {
            $this->error("Empty list", false, true);
            return false;
        }

        $this->list_original = $list;
        $this->list = $list;

        if (isset($options['multiselect']))
        {
            $this->multiselect = $options['multiselect'];
        }

        if (isset($options['template']))
        {
            $this->template = $options['template'];
        }

        $commands = [
            'filter' => [
                'description' => 'Filter the list',
                'keys' => 'f',
                'callback' => [
                    'subcommands' => [
                        'filter_by_text' => [
                            'description' => 'Text/Regex Search',
                            'keys' => '/',
                            'callback' => [$this, 'filter_by_text'],
                            'continue' => false,
                        ],
                        'filter_remove' => [
                            'description' => 'Remove filters - go back to full list',
                            'keys' => 'r',
                            'callback' => [$this, 'filter_remove'],
                            'continue' => false,
                        ],
                    ],
                ],
            ],
            'filter_by_text' => [
                'description' => 'Search list (filter by text entry)',
                'keys' => '/',
                'callback' => [$this, 'filter_by_text'],
            ],
            'focus_up' => [
                'description' => 'Up - move focus up in the list',
                'keys' => 'k',
                'callback' => [$this, 'focus_up'],
            ],
            'focus_down' => [
                'description' => 'Down - move focus down in the list',
                'keys' => 'j',
                'callback' => [$this, 'focus_down'],
            ],
            'focus_top' => [
                'description' => 'Top - move focus to top of list',
                'keys' => 'g',
                'callback' => [$this, 'focus_top'],
            ],
            'focus_bottom' => [
                'description' => 'Bottom - move focus to bottom of list',
                'keys' => 'G',
                'callback' => [$this, 'focus_bottom'],
            ],
        ];

        if (isset($options['commands']))
        {
            $commands = $this->mergeArraysRecursively($commands, $options['commands']);
        }
        $options['commands'] = $commands;

        parent::__construct($main_tool, $options);
    }

    /**
     * Run the listing subcommand
     */
    public function run()
    {
        $count = count($this->list);

        $content_to_display=[];
        $i=0;
        foreach ($this->list as $key => $item)
        {
            // Prep output using template
            $output = $this->template;

            $key_start = strpos($output, '{_KEY}');
            if ($key_start !== false)
            {
                $output = substr_replace($output, $key, $key_start, 6);
            }

            $value_start = strpos($output, '{_VALUE}');
            if ($key_start !== false)
            {
                $output = substr_replace($output, $this->stringify($item), $value_start, 8);
            }

            $this->_fill_item = $item;
            $content = preg_replace_callback('/\{[^\}]+\}/', [$this, '_fill_item_to_template'], $output );
            if ($this->focus == $i)
            {
                $content = "[*] " . $content;
                $content = $this->colorize($content , 'blue', 'light_gray', ['bold']);
            }
            else
            {
                $content = "[ ] " . $content;
            }
            $content_to_display[]= $content;
            $i++;
        }

        $this->clear();
        $this->page_info = $this->paginate($content_to_display, [
            'starting_line' => $this->starting_line,
        ]);

        $continue_loop = $this->promptAndRunCommand($this->commands);

        if ($continue_loop !== false)
        {
            $this->log("Looping!");
            $this->pause();
            $this->run();
        }
    }

        /**
         * Used to fill item data into template string
         *  by preg_replace_callback
         */
        protected $_fill_item;
        protected function _fill_item_to_template ($matches)
        {
            $value = "";
            $format = false;

            $match = $matches[0];
            $match = substr($match, 1, -1);

            $match_exploded = explode("|", $match);
            if (count($match_exploded) > 1)
            {
                $format = array_pop($match_exploded);
            }
            $key_string = array_shift($match_exploded);

            $keys = explode(":", $key_string);
            $target = $this->_fill_item;
            while (!empty($keys))
            {
                $key = array_shift($keys);
                if (isset($target[$key]))
                {
                    $target = $target[$key];
                }
                else
                {
                    $keys = [];
                }
            }
            if (is_string($target))
            {
                $value = $target;
            }

            //var_dump($value);
            if (!empty($format) and !empty($value))
            {
                $value = sprintf($format, $value);
            }
            //var_dump($value);

            return $value;
        }

    /**
     * Built-in commands
     */

    // Reload
    public function reload()
    {
        $list = parent::reload();
        $this->list_original = $list;
        $this->list = $list;
    }

    // Filter - remove filters
    public function filter_remove()
    {
        $this->list = $this->list_original;
        $this->focus_top();
    }

    // Filter - by text/regex (search)
    public function filter_by_text()
    {
        while (true)
        {
            $this->clear();
            $this->hr();
            $this->output("Filter by Text:");
            $this->output(" - Case insensive if search string is all lowercase");
            $this->output(" - Start with / to use RegEx");
            $this->hr();
            $search_pattern = $this->input("Enter text", null, false);

            $current_list = $this->list;
            $filtered_list = [];

            $search_pattern = trim($search_pattern);
            if (empty($search_pattern))
            {
                return;
            }

            $is_regex = (substr($search_pattern, 0, 1) == '/');
            $case_insensitive = (!$is_regex and (strtolower($search_pattern) == $search_pattern));

            foreach ($current_list as $item)
            {
                $json = json_encode($item);
                $match = false;
                if ($is_regex)
                {
                    $match = preg_match($search_pattern, $json);
                }
                elseif ($case_insensitive)
                {
                    $match = ( stripos($json, $search_pattern) !== false );
                }
                else
                {
                    $match = ( strpos($json, $search_pattern) !== false );
                }

                if ($match)
                {
                    $filtered_list[]= $item;
                }
            }

            if (!empty($filtered_list))
            {
                // Results found - display as the new current list
                $this->list = $filtered_list;
                $this->focus_top();
                return;
            }
            else
            {
                // No results - offer to try a new search
                $this->output("No Results found");
                $new_search = $this->confirm("Try a new search?", "y", false, true);
                if ( ! $new_search)
                {
                    return;
                }
                // Otherwise, will continue the loop
            }
        }
    }


    // Focus up/down/top/bottom
    public function focus_up()
    {
        if ($this->focus > 0)
        {
            $this->focus--;
        }
        $this->page_to_focus();
    }
    public function focus_down()
    {
        $max_focus = (count($this->list) - 1);
        if ($this->focus < $max_focus)
        {
            $this->focus++;
        }
        $this->page_to_focus();
    }
    public function focus_top()
    {
        $this->focus = 0;
        $this->page_to_focus();
    }
    public function focus_bottom()
    {
        $max_focus = (count($this->list) - 1);
        $this->focus = $max_focus;
        $this->page_to_focus();
    }

    /**
     * Helper functions
     */

    // Adjust page view to focus
    public function page_to_focus()
    {
        $focus = $this->focus+1;
        if ($focus < $this->starting_line)
        {
            $this->starting_line = $focus;
        }
        if ($focus > $this->page_info['ending_line'])
        {
            $this->starting_line = ($focus - $this->page_info['page_length']) + 1;
        }
    }

    // Get Focused Data
    public function getFocusedKey()
    {
        $list_keys = array_keys($this->list);
        return $list_keys[$this->focus];
    }
    public function getFocusedValue()
    {
        $list_values = array_values($this->list);
        return $list_values[$this->focus];
    }
}

// Note: leave this for packaging ?>
<?php

# 
# hjson-php
# https://github.com/hjson/hjson-php
# v 2.1.0+
#
# MIT License
#

// Note: leave this for packaging ?>
<?php

class HJSONException extends \Exception
{
}

// Note: leave this for packaging ?>
<?php

class HJSONParser
{

    private $text;
    private $at;   // The index of the current character
    private $ch;   // The current character
    private $escapee = [];
    private $keepWsc; // keep whitespace

    public function __construct()
    {
        $this->escapee = [
            '"'  => '"',
            '\'' => '\'',
            "\\" => "\\",
            '/'  => '/',
            'b'  => chr(8),
            'f'  => chr(12),
            'n'  => "\n",
            'r'  => "\r",
            't'  => "\t"
        ];
    }

    public function parse($source, $options = [])
    {
        $this->keepWsc = $options && isset($options['keepWsc']) && $options['keepWsc'];
        $this->text = $source;
        $data = $this->rootValue();

        if ($options && isset($options['assoc']) && $options['assoc']) {
            $data = json_decode(json_encode($data), true);
        }

        return $data;
    }

    private function resetAt()
    {
        $this->at = 0;
        $this->ch = ' ';
    }

    public function parseWsc($source, $options = [])
    {
        return $this->parse($source, array_merge($options, ['keepWsc' => true]));
    }

    private function isPunctuatorChar($c)
    {
        return $c === '{' || $c === '}' || $c === '[' || $c === ']' || $c === ',' || $c === ':';
    }

    private function checkExit($result)
    {
        $this->white();
        if ($this->ch !== null) {
            $this->error("Syntax error, found trailing characters!");
        }
        return $result;
    }

    private function rootValue()
    {
        // Braces for the root object are optional

        $this->resetAt();
        $this->white();
        switch ($this->ch) {
            case '{':
                return $this->checkExit($this->object());
            case '[':
                return $this->checkExit($this->_array());
        }

        try {
          // assume we have a root object without braces
            return $this->checkExit($this->object(true));
        } catch (HJSONException $e) {
            // test if we are dealing with a single JSON value instead (true/false/null/num/"")
            $this->resetAt();
            try {
                return $this->checkExit($this->value());
            } catch (HJSONException $e2) {
                throw $e;
            } // throw original error
        }
    }

    private function value()
    {
        $this->white();
        switch ($this->ch) {
            case '{':
                return $this->object();
            case '[':
                return $this->_array();
            case '"':
                return $this->string('"');
            case '\'':
                if ($this->peek(0) !== '\'' || $this->peek(1) !== '\'') {
                    return $this->string('\'');
                }
                // Falls through on multiline strings
            default:
                return $this->tfnns();
        }
    }

    private function string($quote)
    {
        // Parse a string value.
        $hex;
        $string = '';
        $uffff;

        // When parsing for string values, we must look for " and \ characters.
        if ($this->ch === $quote) {
            while ($this->next() !== null) {
                if ($this->ch === $quote) {
                    $this->next();
                    return $string;
                }
                if ($this->ch === "\\") {
                    $this->next();
                    if ($this->ch === 'u') {
                        $uffff = '';
                        for ($i = 0; $i < 4; $i++) {
                            $uffff .= $this->next();
                        }
                        if (!ctype_xdigit($uffff)) {
                            $this->error("Bad \\u char");
                        }
                        $string .= mb_convert_encoding(pack('H*', $uffff), 'UTF-8', 'UTF-16BE');
                    } elseif (@$this->escapee[$this->ch]) {
                        $string .= $this->escapee[$this->ch];
                    } else {
                        break;
                    }
                } else {
                    $string .= $this->ch;
                }
            }
        }
        $this->error("Bad string");
    }

    private function _array()
    {
        // Parse an array value.
        // assumeing ch === '['

        $array = [];
        $kw = null;
        $wat = null;

        if ($this->keepWsc) {
            $array['__WSC__'] = [];
            $kw = &$array['__WSC__'];
        }

        $this->next();
        $wat = $this->at;
        $this->white();
        if ($kw !== null) {
            $c = $this->getComment($wat);
            if (trim($c)) {
                $kw[] = $c;
            }
        }

        if ($this->ch === ']') {
            $this->next();
            return $array;  // empty array
        }

        while ($this->ch !== null) {
            $array[] = $this->value();
            $wat = $this->at;
            $this->white();
            // in Hjson the comma is optional and trailing commas are allowed
            if ($this->ch === ',') {
                $this->next();
                $wat = $this->at;
                $this->white();
            }
            if ($kw !== null) {
                $c = $this->getComment($wat);
                if (trim($c)) {
                    $kw[] = $c;
                }
            }
            if ($this->ch === ']') {
                $this->next();
                return $array;
            }
            $this->white();
        }

        $this->error("End of input while parsing an array (did you forget a closing ']'?)");
    }

    private function object($withoutBraces = false)
    {
        // Parse an object value.
        $key = null;
        $object = new \stdClass;
        $kw = null;
        $wat = null;
        if ($this->keepWsc) {
            $kw = new \stdClass;
            $kw->c = new \stdClass;
            $kw->o = [];
            $object->__WSC__ = $kw;
            if ($withoutBraces) {
                $kw->noRootBraces = true;
            }
        }

        if (!$withoutBraces) {
            // assuming ch === '{'
            $this->next();
            $wat = $this->at;
        } else {
            $wat = 1;
        }

        $this->white();
        if ($kw) {
            $this->pushWhite(" ", $kw, $wat);
        }
        if ($this->ch === '}' && !$withoutBraces) {
            $this->next();
            return $object;  // empty object
        }
        while ($this->ch !== null) {
            $key = $this->keyname();
            $this->white();
            $this->next(':');
            // duplicate keys overwrite the previous value
            if ($key !== '') {
                $object->$key = $this->value();
            }
            $wat = $this->at;
            $this->white();
            // in Hjson the comma is optional and trailing commas are allowed
            if ($this->ch === ',') {
                $this->next();
                $wat = $this->at;
                $this->white();
            }
            if ($kw) {
                $this->pushWhite($key, $kw, $wat);
            }
            if ($this->ch === '}' && !$withoutBraces) {
                $this->next();
                return $object;
            }
            $this->white();
        }

        if ($withoutBraces) {
            return $object;
        } else {
            $this->error("End of input while parsing an object (did you forget a closing '}'?)");
        }
    }

    private function pushWhite($key, &$kw, $wat)
    {
        $kw->c->$key = $this->getComment($wat);
        if (trim($key)) {
            $kw->o[] = $key;
        }
    }

    private function white()
    {
        while ($this->ch !== null) {
            // Skip whitespace.
            while ($this->ch && $this->ch <= ' ') {
                $this->next();
            }
            // Hjson allows comments
            if ($this->ch === '#' || $this->ch === '/' && $this->peek(0) === '/') {
                while ($this->ch !== null && $this->ch !== "\n") {
                    $this->next();
                }
            } elseif ($this->ch === '/' && $this->peek(0) === '*') {
                $this->next();
                $this->next();
                while ($this->ch !== null && !($this->ch === '*' && $this->peek(0) === '/')) {
                    $this->next();
                }
                if ($this->ch !== null) {
                    $this->next();
                    $this->next();
                }
            } else {
                break;
            }
        }
    }

    private function error($m)
    {
        $col=0;
        $colBytes = 0;
        $line=1;

        $i = $this->at;
        while ($i > 0) {
            $ch = mb_substr(mb_strcut($this->text, $i - 1), 0, 1);
            $i -= strlen($ch);

            if ($ch === "\n") {
                break;
            }

            $col++;
            $colBytes += strlen($ch);
        }

        for (; $i > 0; $i--) {
            if ($this->text[$i] === "\n") {
                $line++;
            }
        }
        throw new HJSONException("$m at line $line, $col >>>". mb_substr(mb_strcut($this->text, $this->at - $colBytes), 0, 20) ." ...");
    }

    private function next($c = false)
    {
        // If a c parameter is provided, verify that it matches the current character.

        if ($c && $c !== $this->ch) {
            $this->error("Expected '$c' instead of '{$this->ch}'");
        }

        // Get the next character. When there are no more characters,
        // return the empty string.
        $this->ch = (strlen($this->text) > $this->at) ? mb_substr(mb_strcut($this->text, $this->at), 0, 1) : null;
        $this->at += strlen($this->ch);
        return $this->ch;
    }

    private function peek($offs)
    {
        // range check is not required
        if ($offs >= 0) {
            return mb_substr(mb_strcut($this->text, $this->at), $offs, 1);
        } else {
            return mb_substr(mb_strcut($this->text, 0, $this->at), $offs, 1);
        }
    }

    private function skipIndent($indent)
    {
        $skip = $indent;
        while ($this->ch && $this->ch <= ' ' && $this->ch !== "\n" && $skip-- > 0) {
            $this->next();
        }
    }

    private function mlString()
    {
        // Parse a multiline string value.
        $string = '';
        $triple = 0;

        // we are at ''' +1 - get indent
        $indent = 0;
        while (true) {
            $c = $this->peek(-$indent-5);
            if ($c === null || $c === "\n") {
                break;
            }
            $indent++;
        }

        // skip white/to (newline)
        while ($this->ch !== null && $this->ch <= ' ' && $this->ch !== "\n") {
            $this->next();
        }
        if ($this->ch === "\n") {
            $this->next();
            $this->skipIndent($indent);
        }

        // When parsing multiline string values, we must look for ' characters.
        while (true) {
            if ($this->ch === null) {
                $this->error("Bad multiline string");
            } elseif ($this->ch === '\'') {
                $triple++;
                $this->next();
                if ($triple === 3) {
                    if (substr($string, -1) === "\n") {
                        $string = mb_substr($string, 0, -1); // remove last EOL
                    }
                    return $string;
                } else {
                    continue;
                }
            } else {
                while ($triple > 0) {
                    $string .= '\'';
                    $triple--;
                }
            }
            if ($this->ch === "\n") {
                $string .= "\n";
                $this->next();
                $this->skipIndent($indent);
            } else {
                if ($this->ch !== "\r") {
                    $string .= $this->ch;
                }
                $this->next();
            }
        }
    }

    private function keyname()
    {
        // quotes for keys are optional in Hjson
        // unless they include {}[],: or whitespace.

        if ($this->ch === '"') {
            return $this->string('"');
        } else if ($this->ch === '\'') {
            return $this->string('\'');
        }

        $name = "";
        $start = $this->at;
        $space = -1;

        while (true) {
            if ($this->ch === ':') {
                if ($name === '') {
                    $this->error("Found ':' but no key name (for an empty key name use quotes)");
                } elseif ($space >=0 && $space !== mb_strlen($name)) {
                    $this->at = $start + $space;
                    $this->error("Found whitespace in your key name (use quotes to include)");
                }
                return $name;
            } elseif ($this->ch <= ' ') {
                if (!$this->ch) {
                    $this->error("Found EOF while looking for a key name (check your syntax)");
                } elseif ($space < 0) {
                    $space = mb_strlen($name);
                }
            } elseif ($this->isPunctuatorChar($this->ch)) {
                $this->error("Found '{$this->ch}' where a key name was expected (check your syntax or use quotes if the key name includes {}[],: or whitespace)");
            } else {
                $name .= $this->ch;
            }
            $this->next();
        }
    }

    private function tfnns()
    {
        // Hjson strings can be quoteless
        // returns string, true, false, or null.

        if ($this->isPunctuatorChar($this->ch)) {
            $this->error("Found a punctuator character '{$this->ch}' when expecting a quoteless string (check your syntax)");
        }

        $value = $this->ch;
        while (true) {
            $isEol = $this->next() === null;
            if (mb_strlen($value) === 3 && $value === "'''") {
                return $this->mlString();
            }
            $isEol = $isEol || $this->ch === "\r" || $this->ch === "\n";

            if ($isEol || $this->ch === ',' ||
                $this->ch === '}' || $this->ch === ']' ||
                $this->ch === '#' ||
                $this->ch === '/' && ($this->peek(0) === '/' || $this->peek(0) === '*')
            ) {
                $chf = $value[0];
                switch ($chf) {
                    case 'f':
                        if (trim($value) === "false") {
                            return false;
                        }
                        break;
                    case 'n':
                        if (trim($value) === "null") {
                            return null;
                        }
                        break;
                    case 't':
                        if (trim($value) === "true") {
                            return true;
                        }
                        break;
                    default:
                        if ($chf === '-' || $chf >= '0' && $chf <= '9') {
                            $n = HJSONUtils::tryParseNumber($value);
                            if ($n !== null) {
                                return $n;
                            }
                        }
                }
                if ($isEol) {
                    // remove any whitespace at the end (ignored in quoteless strings)
                    return trim($value);
                }
            }
            $value .= $this->ch;
        }
    }

    private function getComment($wat)
    {
        $i;
        $wat--;
        // remove trailing whitespace
        for ($i = $this->at - 2; $i > $wat && $this->text[$i] <= ' ' && $this->text[$i] !== "\n"; $i--) {
        }

        // but only up to EOL
        if ($this->text[$i] === "\n") {
            $i--;
        }
        if ($this->text[$i] === "\r") {
            $i--;
        }

        $res = mb_substr($this->text, $wat, $i-$wat+1);
        for ($i = 0; $i < mb_strlen($res); $i++) {
            if ($res[$i] > ' ') {
                return $res;
            }
        }

        return "";
    }
}

// Note: leave this for packaging ?>
<?php

/**
 * NOTE: this may return an empty string at the end of the array when the input
 * string ends with a newline character
 */
function HJSON_mb_str_split($string)
{
    return preg_split('/(?<!^)/u', $string);
}

class HJSONStringifier
{

    // needsEscape tests if the string can be written without escapes
    private $needsEscape = '/[\\\"\x00-\x1f\x7f-\x9f\x{00ad}\x{0600}-\x{0604}\x{070f}\x{17b4}\x{17b5}\x{200c}-\x{200f}\x{2028}-\x{202f}\x{2060}-\x{206f}\x{feff}\x{fff0}-\x{ffff}\x]/u';
    // needsQuotes tests if the string can be written as a quoteless string (includes needsEscape but without \\ and \")
    private $needsQuotes = '/^\\s|^"|^\'|^\'\'\'|^#|^\\/\\*|^\\/\\/|^\\{|^\\}|^\\[|^\\]|^:|^,|\\s$|[\x00-\x1f\x7f-\x9f\x{00ad}\x{0600}-\x{0604}\x{070f}\x{17b4}\x{17b5}\x{200c}-\x{200f}\x{2028}-\x{202f}\x{2060}-\x{206f}\x{feff}\x{fff0}-\x{ffff}\x]/u';
    // needsEscapeML tests if the string can be written as a multiline string (includes needsEscape but without \n, \r, \\ and \")
    private $needsEscapeML = '/^\\s+$|\'\'\'|[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f\x{00ad}\x{0600}-\x{0604}\x{070f}\x{17b4}\x{17b5}\x{200c}-\x{200f}\x{2028}-\x{202f}\x{2060}-\x{206f}\x{feff}\x{fff0}-\x{ffff}\x]/u';
    private $startsWithKeyword = '/^(true|false|null)\s*((,|\]|\}|#|\/\/|\/\*).*)?$/';
    private $needsEscapeName = '/[,\{\[\}\]\s:#"\']|\/\/|\/\*|\'\'\'/';
    private $gap = '';
    private $indent = '  ';

    // options
    private $eol;
    private $keepWsc;
    private $bracesSameLine;
    private $quoteAlways;
    private $forceKeyQuotes;
    private $emitRootBraces;

    private $defaultBracesSameLine = false;

    public function __construct()
    {
        $this->meta = [
            "\t" => "\\t",
            "\n" => "\\n",
            "\r" => "\\r",
            '"'  => '\\"',
            '\''  => '\\\'',
            '\\' => "\\\\"
        ];
        $this->meta[chr(8)] = '\\b';
        $this->meta[chr(12)] = '\\f';
    }


    public function stringify($value, $opt = [])
    {
        $this->eol = PHP_EOL;
        $this->indent = '  ';
        $this->keepWsc = false;
        $this->bracesSameLine = $this->defaultBracesSameLine;
        $this->quoteAlways = false;
        $this->forceKeyQuotes = false;
        $this->emitRootBraces = true;
        $space = null;

        if ($opt && is_array($opt)) {
            if (@$opt['eol'] === "\n" || @$opt['eol'] === "\r\n") {
                $this->eol = $opt['eol'];
            }
            $space = @$opt['space'];
            $this->keepWsc = @$opt['keepWsc'];
            $this->bracesSameLine = @$opt['bracesSameLine'] || $this->defaultBracesSameLine;
            $this->emitRootBraces = @$opt['emitRootBraces'];
            $this->quoteAlways = @$opt['quotes'] === 'always';
            $this->forceKeyQuotes = @$opt['keyQuotes'] === 'always';
        }

        // If the space parameter is a number, make an indent string containing that
        // many spaces. If it is a string, it will be used as the indent string.
        if (is_int($space)) {
            $this->indent = '';
            for ($i = 0; $i < $space; $i++) {
                $this->indent .= ' ';
            }
        } elseif (is_string($space)) {
            $this->indent = $space;
        }

        // Return the result of stringifying the value.
        return $this->str($value, null, true, true);
    }

    public function stringifyWsc($value, $opt = [])
    {
        return $this->stringify($value, array_merge($opt, ['keepWsc' => true]));
    }

    private function isWhite($c)
    {
        return $c <= ' ';
    }

    private function quoteReplace($string)
    {
        mb_ereg_search_init($string, $this->needsEscape);
        $r = mb_ereg_search();
        $chars = HJSON_mb_str_split($string);
        $chars = array_map(function ($char) {
            if (preg_match($this->needsEscape, $char)) {
                $a = $char;
                $c = @$this->meta[$a] ?: null;
                if (gettype($c) === 'string') {
                    return $c;
                } else {
                    return $char;
                }
            } else {
                return $char;
            }
        }, $chars);

        return implode('', $chars);
    }

    private function quote($string = null, $gap = null, $hasComment = null, $isRootObject = null)
    {
        if (!$string) {
            return '""';
        }

        // Check if we can insert this string without quotes
        // see hjson syntax (must not parse as true, false, null or number)
        if ($this->quoteAlways || $hasComment ||
            preg_match($this->needsQuotes, $string) ||
            HJSONUtils::tryParseNumber($string, true) !== null ||
            preg_match($this->startsWithKeyword, $string)) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can safely slap some quotes around it.
            // Otherwise we first check if the string can be expressed in multiline
            // format or we must replace the offending characters with safe escape
            // sequences.

            if (!preg_match($this->needsEscape, $string)) {
                return '"' . $string . '"';
            } elseif (!preg_match($this->needsEscapeML, $string) && !$isRootObject) {
                return $this->mlString($string, $gap);
            } else {
                return '"' . $this->quoteReplace($string) . '"';
            }
        } else {
            // return without quotes
            return $string;
        }
    }

    private function mlString($string, $gap)
    {
        // wrap the string into the ''' (multiline) format

        $a = explode("\n", mb_ereg_replace("\r", "", $string));
        $gap .= $this->indent;

        if (count($a) === 1) {
            // The string contains only a single line. We still use the multiline
            // format as it avoids escaping the \ character (e.g. when used in a
            // regex).
            return "'''" . $a[0] . "'''";
        } else {
            $res = $this->eol . $gap . "'''";
            for ($i = 0; $i < count($a); $i++) {
                $res .= $this->eol;
                if ($a[$i]) {
                    $res .= $gap . $a[$i];
                }
            }
            return $res . $this->eol . $gap . "'''";
        }
    }

    private function quoteName($name)
    {
        if (!$name) {
            return '""';
        }

        // Check if we can insert this name without quotes
        if (preg_match($this->needsEscapeName, $name)) {
            return '"' . (preg_match($this->needsEscape, $name) ? $this->quoteReplace($name) : $name) . '"';
        } else {
            // return without quotes
            return $name;
        }
    }

    private function str($value, $hasComment = null, $noIndent = null, $isRootObject = null)
    {
        // Produce a string from value.

        $startsWithNL = function ($str) {
            return $str && $str[$str[0] === "\r" ? 1 : 0] === "\n";
        };
        $testWsc = function ($str) use ($startsWithNL) {
            return $str && !$startsWithNL($str);
        };
        $wsc = function ($str) {
            if (!$str) {
                return "";
            }
            for ($i = 0; $i < mb_strlen($str); $i++) {
                $c = $str[$i];
                if ($c === "\n" ||
                    $c === '#' ||
                    $c === '/' && ($str[$i+1] === '/' || $str[$i+1] === '*')) {
                    break;
                }
                if ($c > ' ') {
                    return ' # ' . $str;
                }
            }
            return $str;
        };

        // What happens next depends on the value's type.
        switch (gettype($value)) {
            case 'string':
                $str = $this->quote($value, $this->gap, $hasComment, $isRootObject);
                return $str;

            case 'integer':
            case 'double':
                return is_numeric($value) ? str_replace('E', 'e', "$value") : 'null';

            case 'boolean':
                return $value ? 'true' : 'false';

            case 'NULL':
                return 'null';

            case 'object':
            case 'array':
                $isArray = is_array($value);

                $isAssocArray = function (array $arr) {
                    if (array() === $arr) {
                        return false;
                    }
                    return array_keys($arr) !== range(0, count($arr) - 1);
                };
                if ($isArray && $isAssocArray($value)) {
                    $value = (object) $value;
                    $isArray = false;
                }

                $kw = null;
                $kwl = null; // whitespace & comments
                if ($this->keepWsc) {
                    if ($isArray) {
                        $kw = @$value['__WSC__'];
                    } else {
                        $kw = @$value->__WSC__;
                    }
                }

                $showBraces = $isArray || !$isRootObject || ($kw ? !@$kw->noRootBraces : $this->emitRootBraces);

                // Make an array to hold the partial results of stringifying this object value.
                $mind = $this->gap;
                if ($showBraces) {
                    $this->gap .= $this->indent;
                }
                $eolMind = $this->eol . $mind;
                $eolGap = $this->eol . $this->gap;
                $prefix = $noIndent || $this->bracesSameLine ? '' : $eolMind;
                $partial = [];

                $k;
                $v; // key, value

                if ($isArray) {
                    // The value is an array. Stringify every element. Use null as a placeholder
                    // for non-JSON values.

                    $length = count($value);
                    if (array_key_exists('__WSC__', $value)) {
                        $length--;
                    }

                    for ($i = 0; $i < $length; $i++) {
                        if ($kw) {
                            $partial[] = $wsc(@$kw[$i]) . $eolGap;
                        }
                        $str = $this->str($value[$i], $kw ? $testWsc(@$kw[$i+1]) : false, true);
                        $partial[] = $str !== null ? $str : 'null';
                    }
                    if ($kw) {
                        $partial[] = $wsc(@$kw[$i]) . $eolMind;
                    }

                    // Join all of the elements together, separated with newline, and wrap them in
                    // brackets.
                    if ($kw) {
                        $v = $prefix . '[' . implode('', $partial) . ']';
                    } elseif (count($partial) === 0) {
                        $v = '[]';
                    } else {
                        $v = $prefix . '[' . $eolGap . implode($eolGap, $partial) . $eolMind . ']';
                    }
                } else {
                    // Otherwise, iterate through all of the keys in the object.

                    if ($kw) {
                        $emptyKey = " ";
                        $kwl = $wsc($kw->c->$emptyKey);
                        $keys = $kw->o;
                        foreach ($value as $k => $vvv) {
                            $keys[] = $k;
                        }
                        $keys = array_unique($keys);

                        for ($i = 0, $length = count($keys); $i < $length; $i++) {
                            $k = $keys[$i];
                            if ($k === '__WSC__') {
                                continue;
                            }
                            if ($showBraces || $i>0 || $kwl) {
                                $partial[] = $kwl . $eolGap;
                            }
                            $kwl = $wsc($kw->c->$k);
                            $v = $this->str($value->$k, $testWsc($kwl));
                            if ($v !== null) {
                                $partial[] = $this->quoteName($k) . ($startsWithNL($v) ? ':' : ': ') . $v;
                            }
                        }
                        if ($showBraces || $kwl) {
                            $partial[] = $kwl . $eolMind;
                        }
                    } else {
                        foreach ($value as $k => $vvv) {
                            $v = $this->str($vvv);
                            if ($v !== null) {
                                $partial[] = $this->quoteName($k) . ($startsWithNL($v) ? ':' : ': ') . $v;
                            }
                        }
                    }

                    // Join all of the member texts together, separated with newlines
                    if (count($partial) === 0) {
                        $v = '{}';
                    } elseif ($showBraces) {
                        // and wrap them in braces
                        if ($kw) {
                            $v = $prefix . '{' . implode('', $partial) . '}';
                        } else {
                            $v = $prefix . '{' . $eolGap . implode($eolGap, $partial) . $eolMind . '}';
                        }
                    } else {
                        $v = implode($kw ? '' : $eolGap, $partial);
                    }
                }

                $this->gap = $mind;
                return $v;
        }
    }
}

// Note: leave this for packaging ?>
<?php

class HJSONUtils
{

    public static function tryParseNumber($text, $stopAtNext = null)
    {
        // Parse a number value.
        $number = null;
        $string = '';
        $leadingZeros = 0;
        $testLeading = true;
        $at = 0;
        $ch = null;
        
        $next = function () use ($text, &$ch, &$at) {
            $ch = mb_strlen($text) > $at ? $text[$at] : null;
            $at++;
            return $ch;
        };

        $next();

        if ($ch === '-') {
            $string = '-';
            $next();
        }

        while ($ch !== null && $ch >= '0' && $ch <= '9') {
            if ($testLeading) {
                if ($ch == '0') {
                    $leadingZeros++;
                } else {
                    $testLeading = false;
                }
            }
            $string .= $ch;
            $next();
        }
        if ($testLeading) {
            $leadingZeros--; // single 0 is allowed
        }
        if ($ch === '.') {
            $string .= '.';
            while ($next() !== null && $ch >= '0' && $ch <= '9') {
                $string .= $ch;
            }
        }
        if ($ch === 'e' || $ch === 'E') {
            $string .= $ch;
            $next();
            if ($ch === '-' || $ch === '+') {
                $string .= $ch;
                $next();
            }
            while ($ch !== null && $ch >= '0' && $ch <= '9') {
                $string .= $ch;
                $next();
            }
        }

        // skip white/to (newline)
        while ($ch !== null && $ch <= ' ') {
            $next();
        }

        if ($stopAtNext) {
            // end scan if we find a control character like ,}] or a comment
            if ($ch === ',' || $ch === '}' || $ch === ']' ||
                $ch === '#' || $ch === '/' && ($text[$at] === '/' || $text[$at] === '*')) {
                $ch = null;
            }
        }

        $number = $string;
        if (is_numeric($string)) {
            $number = 0+$string;
        }


        if ($ch !== null || $leadingZeros || !is_numeric($number)) {
            return null;
        } else {
            return $number;
        }
    }
}

// Note: leave this for packaging ?>
<?php
#
#
# Parsedown
# http://parsedown.org
#
# (c) Emanuil Rusev
# http://erusev.com
#
# For the full license information, view the LICENSE file that was distributed
# with this source code.
#
#

class Parsedown
{
    # ~

    const version = '1.8.0-beta-7';

    # ~

    function text($text)
    {
        $Elements = $this->textElements($text);

        # convert to markup
        $markup = $this->elements($Elements);

        # trim line breaks
        $markup = trim($markup, "\n");

        return $markup;
    }

    protected function textElements($text)
    {
        # make sure no definitions are set
        $this->DefinitionData = array();

        # standardize line breaks
        $text = str_replace(array("\r\n", "\r"), "\n", $text);

        # remove surrounding line breaks
        $text = trim($text, "\n");

        # split text into lines
        $lines = explode("\n", $text);

        # iterate through lines to identify blocks
        return $this->linesElements($lines);
    }

    #
    # Setters
    #

    function setBreaksEnabled($breaksEnabled)
    {
        $this->breaksEnabled = $breaksEnabled;

        return $this;
    }

    protected $breaksEnabled;

    function setMarkupEscaped($markupEscaped)
    {
        $this->markupEscaped = $markupEscaped;

        return $this;
    }

    protected $markupEscaped;

    function setUrlsLinked($urlsLinked)
    {
        $this->urlsLinked = $urlsLinked;

        return $this;
    }

    protected $urlsLinked = true;

    function setSafeMode($safeMode)
    {
        $this->safeMode = (bool) $safeMode;

        return $this;
    }

    protected $safeMode;

    function setStrictMode($strictMode)
    {
        $this->strictMode = (bool) $strictMode;

        return $this;
    }

    protected $strictMode;

    protected $safeLinksWhitelist = array(
        'http://',
        'https://',
        'ftp://',
        'ftps://',
        'mailto:',
        'tel:',
        'data:image/png;base64,',
        'data:image/gif;base64,',
        'data:image/jpeg;base64,',
        'irc:',
        'ircs:',
        'git:',
        'ssh:',
        'news:',
        'steam:',
    );

    #
    # Lines
    #

    protected $BlockTypes = array(
        '#' => array('Header'),
        '*' => array('Rule', 'List'),
        '+' => array('List'),
        '-' => array('SetextHeader', 'Table', 'Rule', 'List'),
        '0' => array('List'),
        '1' => array('List'),
        '2' => array('List'),
        '3' => array('List'),
        '4' => array('List'),
        '5' => array('List'),
        '6' => array('List'),
        '7' => array('List'),
        '8' => array('List'),
        '9' => array('List'),
        ':' => array('Table'),
        '<' => array('Comment', 'Markup'),
        '=' => array('SetextHeader'),
        '>' => array('Quote'),
        '[' => array('Reference'),
        '_' => array('Rule'),
        '`' => array('FencedCode'),
        '|' => array('Table'),
        '~' => array('FencedCode'),
    );

    # ~

    protected $unmarkedBlockTypes = array(
        'Code',
    );

    #
    # Blocks
    #

    protected function lines(array $lines)
    {
        return $this->elements($this->linesElements($lines));
    }

    protected function linesElements(array $lines)
    {
        $Elements = array();
        $CurrentBlock = null;

        foreach ($lines as $line)
        {
            if (chop($line) === '')
            {
                if (isset($CurrentBlock))
                {
                    $CurrentBlock['interrupted'] = (isset($CurrentBlock['interrupted'])
                        ? $CurrentBlock['interrupted'] + 1 : 1
                    );
                }

                continue;
            }

            while (($beforeTab = strstr($line, "\t", true)) !== false)
            {
                $shortage = 4 - mb_strlen($beforeTab, 'utf-8') % 4;

                $line = $beforeTab
                    . str_repeat(' ', $shortage)
                    . substr($line, strlen($beforeTab) + 1)
                ;
            }

            $indent = strspn($line, ' ');

            $text = $indent > 0 ? substr($line, $indent) : $line;

            # ~

            $Line = array('body' => $line, 'indent' => $indent, 'text' => $text);

            # ~

            if (isset($CurrentBlock['continuable']))
            {
                $methodName = 'block' . $CurrentBlock['type'] . 'Continue';
                $Block = $this->$methodName($Line, $CurrentBlock);

                if (isset($Block))
                {
                    $CurrentBlock = $Block;

                    continue;
                }
                else
                {
                    if ($this->isBlockCompletable($CurrentBlock['type']))
                    {
                        $methodName = 'block' . $CurrentBlock['type'] . 'Complete';
                        $CurrentBlock = $this->$methodName($CurrentBlock);
                    }
                }
            }

            # ~

            $marker = $text[0];

            # ~

            $blockTypes = $this->unmarkedBlockTypes;

            if (isset($this->BlockTypes[$marker]))
            {
                foreach ($this->BlockTypes[$marker] as $blockType)
                {
                    $blockTypes []= $blockType;
                }
            }

            #
            # ~

            foreach ($blockTypes as $blockType)
            {
                $Block = $this->{"block$blockType"}($Line, $CurrentBlock);

                if (isset($Block))
                {
                    $Block['type'] = $blockType;

                    if ( ! isset($Block['identified']))
                    {
                        if (isset($CurrentBlock))
                        {
                            $Elements[] = $this->extractElement($CurrentBlock);
                        }

                        $Block['identified'] = true;
                    }

                    if ($this->isBlockContinuable($blockType))
                    {
                        $Block['continuable'] = true;
                    }

                    $CurrentBlock = $Block;

                    continue 2;
                }
            }

            # ~

            if (isset($CurrentBlock) and $CurrentBlock['type'] === 'Paragraph')
            {
                $Block = $this->paragraphContinue($Line, $CurrentBlock);
            }

            if (isset($Block))
            {
                $CurrentBlock = $Block;
            }
            else
            {
                if (isset($CurrentBlock))
                {
                    $Elements[] = $this->extractElement($CurrentBlock);
                }

                $CurrentBlock = $this->paragraph($Line);

                $CurrentBlock['identified'] = true;
            }
        }

        # ~

        if (isset($CurrentBlock['continuable']) and $this->isBlockCompletable($CurrentBlock['type']))
        {
            $methodName = 'block' . $CurrentBlock['type'] . 'Complete';
            $CurrentBlock = $this->$methodName($CurrentBlock);
        }

        # ~

        if (isset($CurrentBlock))
        {
            $Elements[] = $this->extractElement($CurrentBlock);
        }

        # ~

        return $Elements;
    }

    protected function extractElement(array $Component)
    {
        if ( ! isset($Component['element']))
        {
            if (isset($Component['markup']))
            {
                $Component['element'] = array('rawHtml' => $Component['markup']);
            }
            elseif (isset($Component['hidden']))
            {
                $Component['element'] = array();
            }
        }

        return $Component['element'];
    }

    protected function isBlockContinuable($Type)
    {
        return method_exists($this, 'block' . $Type . 'Continue');
    }

    protected function isBlockCompletable($Type)
    {
        return method_exists($this, 'block' . $Type . 'Complete');
    }

    #
    # Code

    protected function blockCode($Line, $Block = null)
    {
        if (isset($Block) and $Block['type'] === 'Paragraph' and ! isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['indent'] >= 4)
        {
            $text = substr($Line['body'], 4);

            $Block = array(
                'element' => array(
                    'name' => 'pre',
                    'element' => array(
                        'name' => 'code',
                        'text' => $text,
                    ),
                ),
            );

            return $Block;
        }
    }

    protected function blockCodeContinue($Line, $Block)
    {
        if ($Line['indent'] >= 4)
        {
            if (isset($Block['interrupted']))
            {
                $Block['element']['element']['text'] .= str_repeat("\n", $Block['interrupted']);

                unset($Block['interrupted']);
            }

            $Block['element']['element']['text'] .= "\n";

            $text = substr($Line['body'], 4);

            $Block['element']['element']['text'] .= $text;

            return $Block;
        }
    }

    protected function blockCodeComplete($Block)
    {
        return $Block;
    }

    #
    # Comment

    protected function blockComment($Line)
    {
        if ($this->markupEscaped or $this->safeMode)
        {
            return;
        }

        if (strpos($Line['text'], '<!--') === 0)
        {
            $Block = array(
                'element' => array(
                    'rawHtml' => $Line['body'],
                    'autobreak' => true,
                ),
            );

            if (strpos($Line['text'], '-->') !== false)
            {
                $Block['closed'] = true;
            }

            return $Block;
        }
    }

    protected function blockCommentContinue($Line, array $Block)
    {
        if (isset($Block['closed']))
        {
            return;
        }

        $Block['element']['rawHtml'] .= "\n" . $Line['body'];

        if (strpos($Line['text'], '-->') !== false)
        {
            $Block['closed'] = true;
        }

        return $Block;
    }

    #
    # Fenced Code

    protected function blockFencedCode($Line)
    {
        $marker = $Line['text'][0];

        $openerLength = strspn($Line['text'], $marker);

        if ($openerLength < 3)
        {
            return;
        }

        $infostring = trim(substr($Line['text'], $openerLength), "\t ");

        if (strpos($infostring, '`') !== false)
        {
            return;
        }

        $Element = array(
            'name' => 'code',
            'text' => '',
        );

        if ($infostring !== '')
        {
            /**
             * https://www.w3.org/TR/2011/WD-html5-20110525/elements.html#classes
             * Every HTML element may have a class attribute specified.
             * The attribute, if specified, must have a value that is a set
             * of space-separated tokens representing the various classes
             * that the element belongs to.
             * [...]
             * The space characters, for the purposes of this specification,
             * are U+0020 SPACE, U+0009 CHARACTER TABULATION (tab),
             * U+000A LINE FEED (LF), U+000C FORM FEED (FF), and
             * U+000D CARRIAGE RETURN (CR).
             */
            $language = substr($infostring, 0, strcspn($infostring, " \t\n\f\r"));

            $Element['attributes'] = array('class' => "language-$language");
        }

        $Block = array(
            'char' => $marker,
            'openerLength' => $openerLength,
            'element' => array(
                'name' => 'pre',
                'element' => $Element,
            ),
        );

        return $Block;
    }

    protected function blockFencedCodeContinue($Line, $Block)
    {
        if (isset($Block['complete']))
        {
            return;
        }

        if (isset($Block['interrupted']))
        {
            $Block['element']['element']['text'] .= str_repeat("\n", $Block['interrupted']);

            unset($Block['interrupted']);
        }

        if (($len = strspn($Line['text'], $Block['char'])) >= $Block['openerLength']
            and chop(substr($Line['text'], $len), ' ') === ''
        ) {
            $Block['element']['element']['text'] = substr($Block['element']['element']['text'], 1);

            $Block['complete'] = true;

            return $Block;
        }

        $Block['element']['element']['text'] .= "\n" . $Line['body'];

        return $Block;
    }

    protected function blockFencedCodeComplete($Block)
    {
        return $Block;
    }

    #
    # Header

    protected function blockHeader($Line)
    {
        $level = strspn($Line['text'], '#');

        if ($level > 6)
        {
            return;
        }

        $text = trim($Line['text'], '#');

        if ($this->strictMode and isset($text[0]) and $text[0] !== ' ')
        {
            return;
        }

        $text = trim($text, ' ');

        $Block = array(
            'element' => array(
                'name' => 'h' . $level,
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $text,
                    'destination' => 'elements',
                )
            ),
        );

        return $Block;
    }

    #
    # List

    protected function blockList($Line, array $CurrentBlock = null)
    {
        list($name, $pattern) = $Line['text'][0] <= '-' ? array('ul', '[*+-]') : array('ol', '[0-9]{1,9}+[.\)]');

        if (preg_match('/^('.$pattern.'([ ]++|$))(.*+)/', $Line['text'], $matches))
        {
            $contentIndent = strlen($matches[2]);

            if ($contentIndent >= 5)
            {
                $contentIndent -= 1;
                $matches[1] = substr($matches[1], 0, -$contentIndent);
                $matches[3] = str_repeat(' ', $contentIndent) . $matches[3];
            }
            elseif ($contentIndent === 0)
            {
                $matches[1] .= ' ';
            }

            $markerWithoutWhitespace = strstr($matches[1], ' ', true);

            $Block = array(
                'indent' => $Line['indent'],
                'pattern' => $pattern,
                'data' => array(
                    'type' => $name,
                    'marker' => $matches[1],
                    'markerType' => ($name === 'ul' ? $markerWithoutWhitespace : substr($markerWithoutWhitespace, -1)),
                ),
                'element' => array(
                    'name' => $name,
                    'elements' => array(),
                ),
            );
            $Block['data']['markerTypeRegex'] = preg_quote($Block['data']['markerType'], '/');

            if ($name === 'ol')
            {
                $listStart = ltrim(strstr($matches[1], $Block['data']['markerType'], true), '0') ?: '0';

                if ($listStart !== '1')
                {
                    if (
                        isset($CurrentBlock)
                        and $CurrentBlock['type'] === 'Paragraph'
                        and ! isset($CurrentBlock['interrupted'])
                    ) {
                        return;
                    }

                    $Block['element']['attributes'] = array('start' => $listStart);
                }
            }

            $Block['li'] = array(
                'name' => 'li',
                'handler' => array(
                    'function' => 'li',
                    'argument' => !empty($matches[3]) ? array($matches[3]) : array(),
                    'destination' => 'elements'
                )
            );

            $Block['element']['elements'] []= & $Block['li'];

            return $Block;
        }
    }

    protected function blockListContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']) and empty($Block['li']['handler']['argument']))
        {
            return null;
        }

        $requiredIndent = ($Block['indent'] + strlen($Block['data']['marker']));

        if ($Line['indent'] < $requiredIndent
            and (
                (
                    $Block['data']['type'] === 'ol'
                    and preg_match('/^[0-9]++'.$Block['data']['markerTypeRegex'].'(?:[ ]++(.*)|$)/', $Line['text'], $matches)
                ) or (
                    $Block['data']['type'] === 'ul'
                    and preg_match('/^'.$Block['data']['markerTypeRegex'].'(?:[ ]++(.*)|$)/', $Line['text'], $matches)
                )
            )
        ) {
            if (isset($Block['interrupted']))
            {
                $Block['li']['handler']['argument'] []= '';

                $Block['loose'] = true;

                unset($Block['interrupted']);
            }

            unset($Block['li']);

            $text = isset($matches[1]) ? $matches[1] : '';

            $Block['indent'] = $Line['indent'];

            $Block['li'] = array(
                'name' => 'li',
                'handler' => array(
                    'function' => 'li',
                    'argument' => array($text),
                    'destination' => 'elements'
                )
            );

            $Block['element']['elements'] []= & $Block['li'];

            return $Block;
        }
        elseif ($Line['indent'] < $requiredIndent and $this->blockList($Line))
        {
            return null;
        }

        if ($Line['text'][0] === '[' and $this->blockReference($Line))
        {
            return $Block;
        }

        if ($Line['indent'] >= $requiredIndent)
        {
            if (isset($Block['interrupted']))
            {
                $Block['li']['handler']['argument'] []= '';

                $Block['loose'] = true;

                unset($Block['interrupted']);
            }

            $text = substr($Line['body'], $requiredIndent);

            $Block['li']['handler']['argument'] []= $text;

            return $Block;
        }

        if ( ! isset($Block['interrupted']))
        {
            $text = preg_replace('/^[ ]{0,'.$requiredIndent.'}+/', '', $Line['body']);

            $Block['li']['handler']['argument'] []= $text;

            return $Block;
        }
    }

    protected function blockListComplete(array $Block)
    {
        if (isset($Block['loose']))
        {
            foreach ($Block['element']['elements'] as &$li)
            {
                if (end($li['handler']['argument']) !== '')
                {
                    $li['handler']['argument'] []= '';
                }
            }
        }

        return $Block;
    }

    #
    # Quote

    protected function blockQuote($Line)
    {
        if (preg_match('/^>[ ]?+(.*+)/', $Line['text'], $matches))
        {
            $Block = array(
                'element' => array(
                    'name' => 'blockquote',
                    'handler' => array(
                        'function' => 'linesElements',
                        'argument' => (array) $matches[1],
                        'destination' => 'elements',
                    )
                ),
            );

            return $Block;
        }
    }

    protected function blockQuoteContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['text'][0] === '>' and preg_match('/^>[ ]?+(.*+)/', $Line['text'], $matches))
        {
            $Block['element']['handler']['argument'] []= $matches[1];

            return $Block;
        }

        if ( ! isset($Block['interrupted']))
        {
            $Block['element']['handler']['argument'] []= $Line['text'];

            return $Block;
        }
    }

    #
    # Rule

    protected function blockRule($Line)
    {
        $marker = $Line['text'][0];

        if (substr_count($Line['text'], $marker) >= 3 and chop($Line['text'], " $marker") === '')
        {
            $Block = array(
                'element' => array(
                    'name' => 'hr',
                ),
            );

            return $Block;
        }
    }

    #
    # Setext

    protected function blockSetextHeader($Line, array $Block = null)
    {
        if ( ! isset($Block) or $Block['type'] !== 'Paragraph' or isset($Block['interrupted']))
        {
            return;
        }

        if ($Line['indent'] < 4 and chop(chop($Line['text'], ' '), $Line['text'][0]) === '')
        {
            $Block['element']['name'] = $Line['text'][0] === '=' ? 'h1' : 'h2';

            return $Block;
        }
    }

    #
    # Markup

    protected function blockMarkup($Line)
    {
        if ($this->markupEscaped or $this->safeMode)
        {
            return;
        }

        if (preg_match('/^<[\/]?+(\w*)(?:[ ]*+'.$this->regexHtmlAttribute.')*+[ ]*+(\/)?>/', $Line['text'], $matches))
        {
            $element = strtolower($matches[1]);

            if (in_array($element, $this->textLevelElements))
            {
                return;
            }

            $Block = array(
                'name' => $matches[1],
                'element' => array(
                    'rawHtml' => $Line['text'],
                    'autobreak' => true,
                ),
            );

            return $Block;
        }
    }

    protected function blockMarkupContinue($Line, array $Block)
    {
        if (isset($Block['closed']) or isset($Block['interrupted']))
        {
            return;
        }

        $Block['element']['rawHtml'] .= "\n" . $Line['body'];

        return $Block;
    }

    #
    # Reference

    protected function blockReference($Line)
    {
        if (strpos($Line['text'], ']') !== false
            and preg_match('/^\[(.+?)\]:[ ]*+<?(\S+?)>?(?:[ ]+["\'(](.+)["\')])?[ ]*+$/', $Line['text'], $matches)
        ) {
            $id = strtolower($matches[1]);

            $Data = array(
                'url' => $matches[2],
                'title' => isset($matches[3]) ? $matches[3] : null,
            );

            $this->DefinitionData['Reference'][$id] = $Data;

            $Block = array(
                'element' => array(),
            );

            return $Block;
        }
    }

    #
    # Table

    protected function blockTable($Line, array $Block = null)
    {
        if ( ! isset($Block) or $Block['type'] !== 'Paragraph' or isset($Block['interrupted']))
        {
            return;
        }

        if (
            strpos($Block['element']['handler']['argument'], '|') === false
            and strpos($Line['text'], '|') === false
            and strpos($Line['text'], ':') === false
            or strpos($Block['element']['handler']['argument'], "\n") !== false
        ) {
            return;
        }

        if (chop($Line['text'], ' -:|') !== '')
        {
            return;
        }

        $alignments = array();

        $divider = $Line['text'];

        $divider = trim($divider);
        $divider = trim($divider, '|');

        $dividerCells = explode('|', $divider);

        foreach ($dividerCells as $dividerCell)
        {
            $dividerCell = trim($dividerCell);

            if ($dividerCell === '')
            {
                return;
            }

            $alignment = null;

            if ($dividerCell[0] === ':')
            {
                $alignment = 'left';
            }

            if (substr($dividerCell, - 1) === ':')
            {
                $alignment = $alignment === 'left' ? 'center' : 'right';
            }

            $alignments []= $alignment;
        }

        # ~

        $HeaderElements = array();

        $header = $Block['element']['handler']['argument'];

        $header = trim($header);
        $header = trim($header, '|');

        $headerCells = explode('|', $header);

        if (count($headerCells) !== count($alignments))
        {
            return;
        }

        foreach ($headerCells as $index => $headerCell)
        {
            $headerCell = trim($headerCell);

            $HeaderElement = array(
                'name' => 'th',
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $headerCell,
                    'destination' => 'elements',
                )
            );

            if (isset($alignments[$index]))
            {
                $alignment = $alignments[$index];

                $HeaderElement['attributes'] = array(
                    'style' => "text-align: $alignment;",
                );
            }

            $HeaderElements []= $HeaderElement;
        }

        # ~

        $Block = array(
            'alignments' => $alignments,
            'identified' => true,
            'element' => array(
                'name' => 'table',
                'elements' => array(),
            ),
        );

        $Block['element']['elements'] []= array(
            'name' => 'thead',
        );

        $Block['element']['elements'] []= array(
            'name' => 'tbody',
            'elements' => array(),
        );

        $Block['element']['elements'][0]['elements'] []= array(
            'name' => 'tr',
            'elements' => $HeaderElements,
        );

        return $Block;
    }

    protected function blockTableContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']))
        {
            return;
        }

        if (count($Block['alignments']) === 1 or $Line['text'][0] === '|' or strpos($Line['text'], '|'))
        {
            $Elements = array();

            $row = $Line['text'];

            $row = trim($row);
            $row = trim($row, '|');

            preg_match_all('/(?:(\\\\[|])|[^|`]|`[^`]++`|`)++/', $row, $matches);

            $cells = array_slice($matches[0], 0, count($Block['alignments']));

            foreach ($cells as $index => $cell)
            {
                $cell = trim($cell);

                $Element = array(
                    'name' => 'td',
                    'handler' => array(
                        'function' => 'lineElements',
                        'argument' => $cell,
                        'destination' => 'elements',
                    )
                );

                if (isset($Block['alignments'][$index]))
                {
                    $Element['attributes'] = array(
                        'style' => 'text-align: ' . $Block['alignments'][$index] . ';',
                    );
                }

                $Elements []= $Element;
            }

            $Element = array(
                'name' => 'tr',
                'elements' => $Elements,
            );

            $Block['element']['elements'][1]['elements'] []= $Element;

            return $Block;
        }
    }

    #
    # ~
    #

    protected function paragraph($Line)
    {
        return array(
            'type' => 'Paragraph',
            'element' => array(
                'name' => 'p',
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $Line['text'],
                    'destination' => 'elements',
                ),
            ),
        );
    }

    protected function paragraphContinue($Line, array $Block)
    {
        if (isset($Block['interrupted']))
        {
            return;
        }

        $Block['element']['handler']['argument'] .= "\n".$Line['text'];

        return $Block;
    }

    #
    # Inline Elements
    #

    protected $InlineTypes = array(
        '!' => array('Image'),
        '&' => array('SpecialCharacter'),
        '*' => array('Emphasis'),
        ':' => array('Url'),
        '<' => array('UrlTag', 'EmailTag', 'Markup'),
        '[' => array('Link'),
        '_' => array('Emphasis'),
        '`' => array('Code'),
        '~' => array('Strikethrough'),
        '\\' => array('EscapeSequence'),
    );

    # ~

    protected $inlineMarkerList = '!*_&[:<`~\\';

    #
    # ~
    #

    public function line($text, $nonNestables = array())
    {
        return $this->elements($this->lineElements($text, $nonNestables));
    }

    protected function lineElements($text, $nonNestables = array())
    {
        # standardize line breaks
        $text = str_replace(array("\r\n", "\r"), "\n", $text);

        $Elements = array();

        $nonNestables = (empty($nonNestables)
            ? array()
            : array_combine($nonNestables, $nonNestables)
        );

        # $excerpt is based on the first occurrence of a marker

        while ($excerpt = strpbrk($text, $this->inlineMarkerList))
        {
            $marker = $excerpt[0];

            $markerPosition = strlen($text) - strlen($excerpt);

            $Excerpt = array('text' => $excerpt, 'context' => $text);

            foreach ($this->InlineTypes[$marker] as $inlineType)
            {
                # check to see if the current inline type is nestable in the current context

                if (isset($nonNestables[$inlineType]))
                {
                    continue;
                }

                $Inline = $this->{"inline$inlineType"}($Excerpt);

                if ( ! isset($Inline))
                {
                    continue;
                }

                # makes sure that the inline belongs to "our" marker

                if (isset($Inline['position']) and $Inline['position'] > $markerPosition)
                {
                    continue;
                }

                # sets a default inline position

                if ( ! isset($Inline['position']))
                {
                    $Inline['position'] = $markerPosition;
                }

                # cause the new element to 'inherit' our non nestables


                $Inline['element']['nonNestables'] = isset($Inline['element']['nonNestables'])
                    ? array_merge($Inline['element']['nonNestables'], $nonNestables)
                    : $nonNestables
                ;

                # the text that comes before the inline
                $unmarkedText = substr($text, 0, $Inline['position']);

                # compile the unmarked text
                $InlineText = $this->inlineText($unmarkedText);
                $Elements[] = $InlineText['element'];

                # compile the inline
                $Elements[] = $this->extractElement($Inline);

                # remove the examined text
                $text = substr($text, $Inline['position'] + $Inline['extent']);

                continue 2;
            }

            # the marker does not belong to an inline

            $unmarkedText = substr($text, 0, $markerPosition + 1);

            $InlineText = $this->inlineText($unmarkedText);
            $Elements[] = $InlineText['element'];

            $text = substr($text, $markerPosition + 1);
        }

        $InlineText = $this->inlineText($text);
        $Elements[] = $InlineText['element'];

        foreach ($Elements as &$Element)
        {
            if ( ! isset($Element['autobreak']))
            {
                $Element['autobreak'] = false;
            }
        }

        return $Elements;
    }

    #
    # ~
    #

    protected function inlineText($text)
    {
        $Inline = array(
            'extent' => strlen($text),
            'element' => array(),
        );

        $Inline['element']['elements'] = self::pregReplaceElements(
            $this->breaksEnabled ? '/[ ]*+\n/' : '/(?:[ ]*+\\\\|[ ]{2,}+)\n/',
            array(
                array('name' => 'br'),
                array('text' => "\n"),
            ),
            $text
        );

        return $Inline;
    }

    protected function inlineCode($Excerpt)
    {
        $marker = $Excerpt['text'][0];

        if (preg_match('/^(['.$marker.']++)[ ]*+(.+?)[ ]*+(?<!['.$marker.'])\1(?!'.$marker.')/s', $Excerpt['text'], $matches))
        {
            $text = $matches[2];
            $text = preg_replace('/[ ]*+\n/', ' ', $text);

            return array(
                'extent' => strlen($matches[0]),
                'element' => array(
                    'name' => 'code',
                    'text' => $text,
                ),
            );
        }
    }

    protected function inlineEmailTag($Excerpt)
    {
        $hostnameLabel = '[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?';

        $commonMarkEmail = '[a-zA-Z0-9.!#$%&\'*+\/=?^_`{|}~-]++@'
            . $hostnameLabel . '(?:\.' . $hostnameLabel . ')*';

        if (strpos($Excerpt['text'], '>') !== false
            and preg_match("/^<((mailto:)?$commonMarkEmail)>/i", $Excerpt['text'], $matches)
        ){
            $url = $matches[1];

            if ( ! isset($matches[2]))
            {
                $url = "mailto:$url";
            }

            return array(
                'extent' => strlen($matches[0]),
                'element' => array(
                    'name' => 'a',
                    'text' => $matches[1],
                    'attributes' => array(
                        'href' => $url,
                    ),
                ),
            );
        }
    }

    protected function inlineEmphasis($Excerpt)
    {
        if ( ! isset($Excerpt['text'][1]))
        {
            return;
        }

        $marker = $Excerpt['text'][0];

        if ($Excerpt['text'][1] === $marker and preg_match($this->StrongRegex[$marker], $Excerpt['text'], $matches))
        {
            $emphasis = 'strong';
        }
        elseif (preg_match($this->EmRegex[$marker], $Excerpt['text'], $matches))
        {
            $emphasis = 'em';
        }
        else
        {
            return;
        }

        return array(
            'extent' => strlen($matches[0]),
            'element' => array(
                'name' => $emphasis,
                'handler' => array(
                    'function' => 'lineElements',
                    'argument' => $matches[1],
                    'destination' => 'elements',
                )
            ),
        );
    }

    protected function inlineEscapeSequence($Excerpt)
    {
        if (isset($Excerpt['text'][1]) and in_array($Excerpt['text'][1], $this->specialCharacters))
        {
            return array(
                'element' => array('rawHtml' => $Excerpt['text'][1]),
                'extent' => 2,
            );
        }
    }

    protected function inlineImage($Excerpt)
    {
        if ( ! isset($Excerpt['text'][1]) or $Excerpt['text'][1] !== '[')
        {
            return;
        }

        $Excerpt['text']= substr($Excerpt['text'], 1);

        $Link = $this->inlineLink($Excerpt);

        if ($Link === null)
        {
            return;
        }

        $Inline = array(
            'extent' => $Link['extent'] + 1,
            'element' => array(
                'name' => 'img',
                'attributes' => array(
                    'src' => $Link['element']['attributes']['href'],
                    'alt' => $Link['element']['handler']['argument'],
                ),
                'autobreak' => true,
            ),
        );

        $Inline['element']['attributes'] += $Link['element']['attributes'];

        unset($Inline['element']['attributes']['href']);

        return $Inline;
    }

    protected function inlineLink($Excerpt)
    {
        $Element = array(
            'name' => 'a',
            'handler' => array(
                'function' => 'lineElements',
                'argument' => null,
                'destination' => 'elements',
            ),
            'nonNestables' => array('Url', 'Link'),
            'attributes' => array(
                'href' => null,
                'title' => null,
            ),
        );

        $extent = 0;

        $remainder = $Excerpt['text'];

        if (preg_match('/\[((?:[^][]++|(?R))*+)\]/', $remainder, $matches))
        {
            $Element['handler']['argument'] = $matches[1];

            $extent += strlen($matches[0]);

            $remainder = substr($remainder, $extent);
        }
        else
        {
            return;
        }

        if (preg_match('/^[(]\s*+((?:[^ ()]++|[(][^ )]+[)])++)(?:[ ]+("[^"]*+"|\'[^\']*+\'))?\s*+[)]/', $remainder, $matches))
        {
            $Element['attributes']['href'] = $matches[1];

            if (isset($matches[2]))
            {
                $Element['attributes']['title'] = substr($matches[2], 1, - 1);
            }

            $extent += strlen($matches[0]);
        }
        else
        {
            if (preg_match('/^\s*\[(.*?)\]/', $remainder, $matches))
            {
                $definition = strlen($matches[1]) ? $matches[1] : $Element['handler']['argument'];
                $definition = strtolower($definition);

                $extent += strlen($matches[0]);
            }
            else
            {
                $definition = strtolower($Element['handler']['argument']);
            }

            if ( ! isset($this->DefinitionData['Reference'][$definition]))
            {
                return;
            }

            $Definition = $this->DefinitionData['Reference'][$definition];

            $Element['attributes']['href'] = $Definition['url'];
            $Element['attributes']['title'] = $Definition['title'];
        }

        return array(
            'extent' => $extent,
            'element' => $Element,
        );
    }

    protected function inlineMarkup($Excerpt)
    {
        if ($this->markupEscaped or $this->safeMode or strpos($Excerpt['text'], '>') === false)
        {
            return;
        }

        if ($Excerpt['text'][1] === '/' and preg_match('/^<\/\w[\w-]*+[ ]*+>/s', $Excerpt['text'], $matches))
        {
            return array(
                'element' => array('rawHtml' => $matches[0]),
                'extent' => strlen($matches[0]),
            );
        }

        if ($Excerpt['text'][1] === '!' and preg_match('/^<!---?[^>-](?:-?+[^-])*-->/s', $Excerpt['text'], $matches))
        {
            return array(
                'element' => array('rawHtml' => $matches[0]),
                'extent' => strlen($matches[0]),
            );
        }

        if ($Excerpt['text'][1] !== ' ' and preg_match('/^<\w[\w-]*+(?:[ ]*+'.$this->regexHtmlAttribute.')*+[ ]*+\/?>/s', $Excerpt['text'], $matches))
        {
            return array(
                'element' => array('rawHtml' => $matches[0]),
                'extent' => strlen($matches[0]),
            );
        }
    }

    protected function inlineSpecialCharacter($Excerpt)
    {
        if (substr($Excerpt['text'], 1, 1) !== ' ' and strpos($Excerpt['text'], ';') !== false
            and preg_match('/^&(#?+[0-9a-zA-Z]++);/', $Excerpt['text'], $matches)
        ) {
            return array(
                'element' => array('rawHtml' => '&' . $matches[1] . ';'),
                'extent' => strlen($matches[0]),
            );
        }

        return;
    }

    protected function inlineStrikethrough($Excerpt)
    {
        if ( ! isset($Excerpt['text'][1]))
        {
            return;
        }

        if ($Excerpt['text'][1] === '~' and preg_match('/^~~(?=\S)(.+?)(?<=\S)~~/', $Excerpt['text'], $matches))
        {
            return array(
                'extent' => strlen($matches[0]),
                'element' => array(
                    'name' => 'del',
                    'handler' => array(
                        'function' => 'lineElements',
                        'argument' => $matches[1],
                        'destination' => 'elements',
                    )
                ),
            );
        }
    }

    protected function inlineUrl($Excerpt)
    {
        if ($this->urlsLinked !== true or ! isset($Excerpt['text'][2]) or $Excerpt['text'][2] !== '/')
        {
            return;
        }

        if (strpos($Excerpt['context'], 'http') !== false
            and preg_match('/\bhttps?+:[\/]{2}[^\s<]+\b\/*+/ui', $Excerpt['context'], $matches, PREG_OFFSET_CAPTURE)
        ) {
            $url = $matches[0][0];

            $Inline = array(
                'extent' => strlen($matches[0][0]),
                'position' => $matches[0][1],
                'element' => array(
                    'name' => 'a',
                    'text' => $url,
                    'attributes' => array(
                        'href' => $url,
                    ),
                ),
            );

            return $Inline;
        }
    }

    protected function inlineUrlTag($Excerpt)
    {
        if (strpos($Excerpt['text'], '>') !== false and preg_match('/^<(\w++:\/{2}[^ >]++)>/i', $Excerpt['text'], $matches))
        {
            $url = $matches[1];

            return array(
                'extent' => strlen($matches[0]),
                'element' => array(
                    'name' => 'a',
                    'text' => $url,
                    'attributes' => array(
                        'href' => $url,
                    ),
                ),
            );
        }
    }

    # ~

    protected function unmarkedText($text)
    {
        $Inline = $this->inlineText($text);
        return $this->element($Inline['element']);
    }

    #
    # Handlers
    #

    protected function handle(array $Element)
    {
        if (isset($Element['handler']))
        {
            if (!isset($Element['nonNestables']))
            {
                $Element['nonNestables'] = array();
            }

            if (is_string($Element['handler']))
            {
                $function = $Element['handler'];
                $argument = $Element['text'];
                unset($Element['text']);
                $destination = 'rawHtml';
            }
            else
            {
                $function = $Element['handler']['function'];
                $argument = $Element['handler']['argument'];
                $destination = $Element['handler']['destination'];
            }

            $Element[$destination] = $this->{$function}($argument, $Element['nonNestables']);

            if ($destination === 'handler')
            {
                $Element = $this->handle($Element);
            }

            unset($Element['handler']);
        }

        return $Element;
    }

    protected function handleElementRecursive(array $Element)
    {
        return $this->elementApplyRecursive(array($this, 'handle'), $Element);
    }

    protected function handleElementsRecursive(array $Elements)
    {
        return $this->elementsApplyRecursive(array($this, 'handle'), $Elements);
    }

    protected function elementApplyRecursive($closure, array $Element)
    {
        $Element = call_user_func($closure, $Element);

        if (isset($Element['elements']))
        {
            $Element['elements'] = $this->elementsApplyRecursive($closure, $Element['elements']);
        }
        elseif (isset($Element['element']))
        {
            $Element['element'] = $this->elementApplyRecursive($closure, $Element['element']);
        }

        return $Element;
    }

    protected function elementApplyRecursiveDepthFirst($closure, array $Element)
    {
        if (isset($Element['elements']))
        {
            $Element['elements'] = $this->elementsApplyRecursiveDepthFirst($closure, $Element['elements']);
        }
        elseif (isset($Element['element']))
        {
            $Element['element'] = $this->elementsApplyRecursiveDepthFirst($closure, $Element['element']);
        }

        $Element = call_user_func($closure, $Element);

        return $Element;
    }

    protected function elementsApplyRecursive($closure, array $Elements)
    {
        foreach ($Elements as &$Element)
        {
            $Element = $this->elementApplyRecursive($closure, $Element);
        }

        return $Elements;
    }

    protected function elementsApplyRecursiveDepthFirst($closure, array $Elements)
    {
        foreach ($Elements as &$Element)
        {
            $Element = $this->elementApplyRecursiveDepthFirst($closure, $Element);
        }

        return $Elements;
    }

    protected function element(array $Element)
    {
        if ($this->safeMode)
        {
            $Element = $this->sanitiseElement($Element);
        }

        # identity map if element has no handler
        $Element = $this->handle($Element);

        $hasName = isset($Element['name']);

        $markup = '';

        if ($hasName)
        {
            $markup .= '<' . $Element['name'];

            if (isset($Element['attributes']))
            {
                foreach ($Element['attributes'] as $name => $value)
                {
                    if ($value === null)
                    {
                        continue;
                    }

                    $markup .= " $name=\"".self::escape($value).'"';
                }
            }
        }

        $permitRawHtml = false;

        if (isset($Element['text']))
        {
            $text = $Element['text'];
        }
        // very strongly consider an alternative if you're writing an
        // extension
        elseif (isset($Element['rawHtml']))
        {
            $text = $Element['rawHtml'];

            $allowRawHtmlInSafeMode = isset($Element['allowRawHtmlInSafeMode']) && $Element['allowRawHtmlInSafeMode'];
            $permitRawHtml = !$this->safeMode || $allowRawHtmlInSafeMode;
        }

        $hasContent = isset($text) || isset($Element['element']) || isset($Element['elements']);

        if ($hasContent)
        {
            $markup .= $hasName ? '>' : '';

            if (isset($Element['elements']))
            {
                $markup .= $this->elements($Element['elements']);
            }
            elseif (isset($Element['element']))
            {
                $markup .= $this->element($Element['element']);
            }
            else
            {
                if (!$permitRawHtml)
                {
                    $markup .= self::escape($text, true);
                }
                else
                {
                    $markup .= $text;
                }
            }

            $markup .= $hasName ? '</' . $Element['name'] . '>' : '';
        }
        elseif ($hasName)
        {
            $markup .= ' />';
        }

        return $markup;
    }

    protected function elements(array $Elements)
    {
        $markup = '';

        $autoBreak = true;

        foreach ($Elements as $Element)
        {
            if (empty($Element))
            {
                continue;
            }

            $autoBreakNext = (isset($Element['autobreak'])
                ? $Element['autobreak'] : isset($Element['name'])
            );
            // (autobreak === false) covers both sides of an element
            $autoBreak = !$autoBreak ? $autoBreak : $autoBreakNext;

            $markup .= ($autoBreak ? "\n" : '') . $this->element($Element);
            $autoBreak = $autoBreakNext;
        }

        $markup .= $autoBreak ? "\n" : '';

        return $markup;
    }

    # ~

    protected function li($lines)
    {
        $Elements = $this->linesElements($lines);

        if ( ! in_array('', $lines)
            and isset($Elements[0]) and isset($Elements[0]['name'])
            and $Elements[0]['name'] === 'p'
        ) {
            unset($Elements[0]['name']);
        }

        return $Elements;
    }

    #
    # AST Convenience
    #

    /**
     * Replace occurrences $regexp with $Elements in $text. Return an array of
     * elements representing the replacement.
     */
    protected static function pregReplaceElements($regexp, $Elements, $text)
    {
        $newElements = array();

        while (preg_match($regexp, $text, $matches, PREG_OFFSET_CAPTURE))
        {
            $offset = $matches[0][1];
            $before = substr($text, 0, $offset);
            $after = substr($text, $offset + strlen($matches[0][0]));

            $newElements[] = array('text' => $before);

            foreach ($Elements as $Element)
            {
                $newElements[] = $Element;
            }

            $text = $after;
        }

        $newElements[] = array('text' => $text);

        return $newElements;
    }

    #
    # Deprecated Methods
    #

    function parse($text)
    {
        $markup = $this->text($text);

        return $markup;
    }

    protected function sanitiseElement(array $Element)
    {
        static $goodAttribute = '/^[a-zA-Z0-9][a-zA-Z0-9-_]*+$/';
        static $safeUrlNameToAtt  = array(
            'a'   => 'href',
            'img' => 'src',
        );

        if ( ! isset($Element['name']))
        {
            unset($Element['attributes']);
            return $Element;
        }

        if (isset($safeUrlNameToAtt[$Element['name']]))
        {
            $Element = $this->filterUnsafeUrlInAttribute($Element, $safeUrlNameToAtt[$Element['name']]);
        }

        if ( ! empty($Element['attributes']))
        {
            foreach ($Element['attributes'] as $att => $val)
            {
                # filter out badly parsed attribute
                if ( ! preg_match($goodAttribute, $att))
                {
                    unset($Element['attributes'][$att]);
                }
                # dump onevent attribute
                elseif (self::striAtStart($att, 'on'))
                {
                    unset($Element['attributes'][$att]);
                }
            }
        }

        return $Element;
    }

    protected function filterUnsafeUrlInAttribute(array $Element, $attribute)
    {
        foreach ($this->safeLinksWhitelist as $scheme)
        {
            if (self::striAtStart($Element['attributes'][$attribute], $scheme))
            {
                return $Element;
            }
        }

        $Element['attributes'][$attribute] = str_replace(':', '%3A', $Element['attributes'][$attribute]);

        return $Element;
    }

    #
    # Static Methods
    #

    protected static function escape($text, $allowQuotes = false)
    {
        return htmlspecialchars($text, $allowQuotes ? ENT_NOQUOTES : ENT_QUOTES, 'UTF-8');
    }

    protected static function striAtStart($string, $needle)
    {
        $len = strlen($needle);

        if ($len > strlen($string))
        {
            return false;
        }
        else
        {
            return strtolower(substr($string, 0, $len)) === strtolower($needle);
        }
    }

    static function instance($name = 'default')
    {
        if (isset(self::$instances[$name]))
        {
            return self::$instances[$name];
        }

        $instance = new static();

        self::$instances[$name] = $instance;

        return $instance;
    }

    private static $instances = array();

    #
    # Fields
    #

    protected $DefinitionData;

    #
    # Read-Only

    protected $specialCharacters = array(
        '\\', '`', '*', '_', '{', '}', '[', ']', '(', ')', '>', '#', '+', '-', '.', '!', '|', '~'
    );

    protected $StrongRegex = array(
        '*' => '/^[*]{2}((?:\\\\\*|[^*]|[*][^*]*+[*])+?)[*]{2}(?![*])/s',
        '_' => '/^__((?:\\\\_|[^_]|_[^_]*+_)+?)__(?!_)/us',
    );

    protected $EmRegex = array(
        '*' => '/^[*]((?:\\\\\*|[^*]|[*][*][^*]+?[*][*])+?)[*](?![*])/s',
        '_' => '/^_((?:\\\\_|[^_]|__[^_]*__)+?)_(?!_)\b/us',
    );

    protected $regexHtmlAttribute = '[a-zA-Z_:][\w:.-]*+(?:\s*+=\s*+(?:[^"\'=<>`\s]+|"[^"]*+"|\'[^\']*+\'))?+';

    protected $voidElements = array(
        'area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source',
    );

    protected $textLevelElements = array(
        'a', 'br', 'bdo', 'abbr', 'blink', 'nextid', 'acronym', 'basefont',
        'b', 'em', 'big', 'cite', 'small', 'spacer', 'listing',
        'i', 'rp', 'del', 'code',          'strike', 'marquee',
        'q', 'rt', 'ins', 'font',          'strong',
        's', 'tt', 'kbd', 'mark',
        'u', 'xm', 'sub', 'nobr',
                   'sup', 'ruby',
                   'var', 'span',
                   'wbr', 'time',
    );
}

// Note: leave this for packaging ?>
<?php
/**
 * Console Abstract to be extended by specific console tools
 */

// Global Constants
if (!defined('DS'))
{
    define('DS', DIRECTORY_SEPARATOR);
}

// Either log or display all errors
error_reporting(E_ALL);

if (defined('ERRORS') and ERRORS)
{
    // Enable and show errors
    echo "\n\n************************************\n";
    echo "* Displaying all errors & warnings *\n";
    echo "************************************\n\n";
    ini_set('display_errors', 1);
}
else
{
    // Disable PHP Error display
    ini_set('display_errors', 0);
}

if (!defined('PACKAGED') or !PACKAGED)
{
    $lib_files = scandir(__DIR__ . DS . "lib");
    sort($lib_files);
    foreach ($lib_files as $file)
    {
        $path = __DIR__ . DS . "lib" . DS . $file;
        if (is_file($path))
        {
            require_once($path);
        }
    }
}

/**
 * Console Abstract
 * Reusable abstract for creating PHP console utilities
 */
class Console_Abstract extends Command
{

    /**
     * Padding for output
     */
    const DEFAULT_HEIGHT = 30; // lines - if not able to dynamically determine
    const DEFAULT_WIDTH = 130; // characters - if not able to dynamically determine
    const COL1_WIDTH = 20; // percentage of full width
    const COL2_WIDTH = 50; // percentage of full width - col1 + col2

    /**
     * Callable Methods
     */
    protected static $METHODS = [
        'backup',
        'eval_file',
        'install',
        'update',
        'version',
    ];

    /**
     * Methods that are OK to run as root without warning
     */
    protected static $ROOT_METHODS = [
        'help',
        'install',
        'update',
        'version',
    ];

    /**
     * Config options that are hidden from help output
     * - Add config values here that would not typically be overridden by a flag
     * - Cleans up help output and avoids confusion
     */
    protected static $HIDDEN_CONFIG_OPTIONS = [
        'backup_age_limit',
        'backup_dir',
        'browser_exec',
        'cache_lifetime',
        'editor_exec',
        'editor_modify_exec',
        'install_path',
        'step',
        'timezone',
        'update_auto',
        'update_check_hash',
        'update_last_check',
        'update_version_url',
    ];

	/**
	 * Config/option defaults
	 */
    protected $__allow_root = "OK to run as root";
    public $allow_root = false;

    protected $__backup_age_limit = ["Age limit of backups to keep- number of days", "string"];
    public $backup_age_limit = '30';

    protected $__backup_dir = ["Location to save backups", "string"];
    public $backup_dir = null;

    protected $__browser_exec = ["Command to open links in browser - %s for link placeholder via sprintf"];
    protected $browser_exec = 'nohup google-chrome "%s" >/dev/null 2>&1 &';

    protected $__cache_lifetime = ["Default time to cache data in seconds"];
    public $cache_lifetime = 86400; // Default: 24 hours

    protected $__editor_exec = ["Command to open file in editor - %s for filepath placeholder via sprintf"];
    protected $editor_exec = '/usr/bin/vim -c "startinsert" "%s" > `tty`'; // vim in insert mode

    protected $__editor_modify_exec = ["Command to open file in editor to review/modify existing text - %s for filepath placeholder via sprintf"];
    protected $editor_modify_exec = '/usr/bin/vim "%s" > `tty`'; // vim in normal mode

    protected $__install_path = ["Install path of this tool", "string"];
	public $install_path = DS . "usr" . DS . "local" . DS . "bin";

    protected $__ssl_check = "Whether to check SSL certificates with curl";
	public $ssl_check = true;

    protected $__stamp_lines = "Stamp output lines";
	public $stamp_lines = false;

    protected $__step = "Enable stepping points";
	public $step = false;

    protected $__timezone = ["Timezone - from http://php.net/manual/en/timezones.", "string"];
    public $timezone = "US/Eastern";

    /* Default: check every 24 hrs
        24 * 60 * 60 = 86400
    */
    protected $__update_auto = ["How often to automatically check for an update (seconds, 0 to disable)", "int"];
	public $update_auto = 86400;

    protected $__update_last_check = ["Formatted timestap of last update check", "string"];
	public $update_last_check = "";

    // Note: this is configurable, and the child class can also set a default
    //  - empty string = not updatable
    //  - Tip: if using Github md file, use raw URL for simpler parsing
    protected $__update_version_url = ["URL to check for latest version number info", "string"];
	public $update_version_url = "";

    // Note: this is configurable, and the child class can also set a default
    protected $__update_check_hash = ["Whether to check hash of download when updating", "binary"];
	public $update_check_hash = true;

    protected $__verbose = "Enable verbose output";
	public $verbose = false;

    // HJSON Data
    protected $____WSC__ = "HJSON Data for config file";
    public $__WSC__ = null;

    /**
     * Config paths
     */
    protected $config_dir = null;
    protected $config_file = null;
    protected $home_dir = null;

    /**
     * Stuff
     * Child class can override all as needed
     */
    protected $config_initialized = false;
    protected $config_to_save = null;
    protected $dt = null;
    protected $run_stamp = '';
    protected $method = '';

    protected $logged_in_user = '';
    protected $current_user = '';
    protected $logged_in_as_root = false;
    protected $running_as_root = false;
    protected $is_windows = false;

    protected $minimum_php_major_version = '7';

    // Update behavior
    // - DOWNLOAD - download and install update
    // - Other - show text as a custom message
    protected $update_behavior='DOWNLOAD';

    // Set this to false in child class to disable updates
    protected $update_pattern_standard = "~
        download\ latest\ version \s*
        \( \s*
            ( [\d.]+ )
        \s* \) \s* :
        \s* ( \S* ) \s*$
    ~ixm";

    // Set this to false in child class to disable hash check
    protected $hash_pattern_standard = "~
        latest\ version\ hash \s*
        \( \s*
            ( .+ )
        \s* \) \s* :
        \s* ([0-9a-f]+)
    ~ixm";

    // True to use the standard
    // - otherwise, specify pattern string as needed
    protected $update_version_pattern = [ true, 1 ];
    protected $update_download_pattern = [ true, 2 ];
    protected $update_hash_algorithm_pattern = [ true, 1 ];
    protected $update_hash_pattern = [ true, 2 ];

    protected $update_exists = null;
    protected $update_version = "0";
    protected $update_url = "";

    // This is used when packaging via pcon, for convenience,
    //  but will be read dynamically from the download page
    //  to check the downloaded file
    protected $update_hash_algorithm = "md5";
    protected $update_hash = "";
    
    /**
     * Constructor - set up basics
     */
    public function __construct()
    {
        date_default_timezone_set($this->timezone);
        $this->run_stamp = $this->stamp();

        exec('logname', $logged_in_user, $return);
        if ($return == 0 and !empty($logged_in_user))
        {
            $this->logged_in_user = trim(implode($logged_in_user));
        }
        $this->logged_in_as_root = ($this->logged_in_user == 'root');

        exec('whoami', $current_user, $return);
        if ($return == 0 and !empty($current_user))
        {
            $this->current_user = trim(implode($current_user));
        }
        $this->running_as_root = ($this->current_user == 'root');

        $this->is_windows = (strtolower(substr(PHP_OS, 0, 3)) === 'win');

        parent::__construct($this);
    }

    /**
     * Check requirements
     * - Extend in child if needed and pass problems to parent
     */
    protected function checkRequirements($problems=[])
    {
        $this->log("PHP Version: " . PHP_VERSION);
        $this->log("OS: " . PHP_OS);
        $this->log("Windows: " . ($this->is_windows ? "Yes" : "No"));

        $php_version = explode('.', PHP_VERSION);
        $major = (int) $php_version[0];
        if ($major < $this->minimum_php_major_version)
        {
            $problems[]= "This tool is not well tested below PHP " . $this->minimum_php_major_version .
                " - please consider upgrading to PHP " . $this->minimum_php_major_version . ".0 or higher";
        }

        if (!function_exists('curl_version'))
        {
            $problems[]= "This tool requires curl for many features such as update checks and installs - please install php-curl";
        }

        if (!empty($problems))
        {
            $this->error("There are some problems with requirements: \n - " . implode("\n - ", $problems), false, true);
        }
    }

    /**
     * Run - parse args and run method specified
     */
    public static function run($arg_list)
    {
        $class = get_called_class();

        $script = array_shift($arg_list);

        $instance = new $class();

        try
        {
            $instance->initConfig();

            $instance->try_calling($arg_list, true);

        } catch (Exception $e) {
            $instance->error($e->getMessage());
        }
    }

    protected $___backup = [
        "Backup a file or files to the configured backup folder",
        ["Paths to back up", "string", "required"],
        ["Whether to output when backup is complete"]
    ];
    public function backup($files, $output=true)
    {
        $success = true;

        $files = $this->prepArg($files, []);

        if (empty($this->backup_dir))
        {
            $this->warn('Backups are disabled - no backup_dir specified in config', true);
            return;
        }

        if (!is_dir($this->backup_dir))
            mkdir($this->backup_dir, 0755, true);

        foreach ($files as $file)
        {
            $this->output("Backing up $file...", false);
            if (!is_file($file))
            {
                $this->br();
                $this->warn("$file does not exist - skipping", true);
                continue;
            }

            $backup_file = $this->backup_dir . DS . basename($file) . '-' . $this->stamp() . '.bak';
            $this->log(" - copying to $backup_file");

            // Back up target
            $success = ($success and copy($file, $backup_file));
            if ($success)
            {
                $this->output('successful');
            }
            else
            {
                $this->br();
                $this->warn("Failed to back up $file", true);
                continue;
            }
        }

        // Clean up old backups - keep backup_age_limit days worth
        $this->exec("find \"{$this->backup_dir}\" -mtime +{$this->backup_age_limit} -type f -delete");
        
        return $success;
    }

    protected $___eval_file = [
        "Evaluate a php script file, which will have access to all internal methods via '\$this'",
        ["File to evaluate", "string", "required"]
    ];
    public function eval_file($file, ...$evaluation_arguments)
    {
        if (!is_file($file))
        {
            $this->error("File does not exist, check the path: $file");
        }

        if (!is_readable($file))
        {
            $this->error("File is not readable, check permissions: $file");
        }

        require_once($file);
    }

    protected $___install = [
        "Install a packaged PHP console tool",
        ["Install path", "string"],
    ];
    public function install($install_path=null)
    {
        if (!defined('PACKAGED') or !PACKAGED)
        {
            $this->error('Only packaged tools may be installed - package first using PCon (https://cmp.onl/tjNJ)');
        }

        $install_path = $this->prepArg($install_path, null);

        if (empty($install_path))
        {
            $install_path = $this->install_path;
        }

        if ($this->is_windows)
        {
            $this->warn(
                "Since you appear to be running on Windows, you will very likely need to modify your install path" . 
                "\n - The current setting is: " . $install_path . 
                "\n - The desired setting will vay based on your environment, but you'll probably want to use a directory that's in your PATH" .
                "\n - For example, if you're using Git Bash, you may want to use: C:\Program Files\Git\usr\local\bin as your install path " .
                "\n Enter 'y' if the install path is correct and you are ready to install" . 
                "\n Enter 'n' to halt now so you can edit 'install_path' in your config file (" . $this->getConfigFile() . ")", 
                true
            );
        }

        if (!is_dir($install_path))
        {
            $this->warn("Install path ($install_path) does not exist and will be created", true);

            $success = mkdir($install_path, 0755, true);

            if (!$success) $this->error("Failed to create install path ($install_path) - may need higher privileges (eg. sudo or run as admin)");
        }

        $tool_path = __FILE__;
        $filename = basename($tool_path);
        $install_tool_path = $install_path . DS . $filename;

        if (file_exists($install_tool_path))
        {
            $this->warn("This will overwrite the existing executable ($install_tool_path)", true);
        }

        $success = rename($tool_path, $install_tool_path);

        if (!$success) $this->error("Install failed - may need higher privileges (eg. sudo or run as admin)");

        $this->configure('install_path', $install_path, true);
        $this->saveConfig();

        $this->log("Install completed to $install_tool_path with no errors");
    }

    protected $___update = [
        "Update an installed PHP console tool"
    ];
    public function update()
    {
        // Make sure update is available
        if (!$this->updateCheck(false, true)) // auto:false, output:true
        {
            return true;
        }

        // Check prescribed behavior
        if ($this->update_behavior != 'DOWNLOAD')
        {
            $this->output($this->update_behavior);
            return;
        }

        if (!defined('PACKAGED') or !PACKAGED)
        {
            $this->error('Only packaged tools may be updated - package first using PCon (https://cmp.onl/tjNJ), then install');
        }

        // Check install path valid
        $this_filename = basename(__FILE__);
        $config_install_tool_path = $this->install_path . DS . $this_filename;
        if ($config_install_tool_path != __FILE__)
        {
            $this->warn(
                "Install path mismatch.\n" . 
                " - Current tool path: " . __FILE__ . "\n" .
                " - Configured install path: " . $config_install_tool_path . "\n" .
                "Update will be installed to " . $config_install_tool_path,
                true
            );
        }

        // Create install path if needed
        if (!is_dir($this->install_path))
        {
            $this->warn("Install path ($this->install_path) does not exist and will be created", true);

            $success = mkdir($this->install_path, 0755, true);

            if (!$success) $this->error("Failed to create install path ($this->install_path) - may need higher privileges (eg. sudo or run as admin)");
        }

        $this->log('Downloading update to temp file, from ' . $this->update_url);
        $temp_dir = sys_get_temp_dir();
        $temp_path = $temp_dir . DS . $this_filename . time();
        if (is_file($temp_path))
        {
            $success = unlink($temp_path);
            if (!$success) $this->error("Failed to delete existing temp file ($temp_path) - may need higher privileges (eg. sudo or run as admin)");
        }

        $curl = $this->getCurl($this->update_url, true);
        $updated_contents = $this->execCurl($curl);
        if (empty($updated_contents)) $this->error("Download failed - no contents at " . $this->update_url);

        $success = file_put_contents($temp_path, $updated_contents);
        if (!$success) $this->error("Failed to write to temp file ($temp_path) - may need higher privileges (eg. sudo or run as admin)");

        if ($this->update_check_hash)
        {
            $this->log('Checking hash of downloaded file ('.$this->update_hash_algorithm.')');
            $download_hash = hash_file($this->update_hash_algorithm, $temp_path);
            if ($download_hash != $this->update_hash)
            {
                $this->log('Download Hash: ' . $download_hash);
                $this->log('Update Hash: ' . $this->update_hash);
                unlink($temp_path);
                $this->error("Hash of downloaded file is incorrect; check download source");
            }
        }

        $this->log('Installing downloaded file');
        $success = rename($temp_path, $config_install_tool_path);
        $success = $success and chmod($config_install_tool_path, 0755);
        if (!$success) $this->error("Update failed - may need higher privileges (eg. sudo or run as admin)");

        $this->output('Update complete');
    }

    protected $___version = [
        "Output version information"
    ];
    public function version($output=true)
    {
        $class = get_called_class();
        $version_string = $class::SHORTNAME . ' version ' . $class::VERSION;

        if ($output)
        {
            $this->output($version_string);
        }
        else
        {
            return $version_string;
        }
    }

    /**
     * Check for an update, and parse out all relevant information if one exists
     * @param $auto Whether this is an automatic check or triggered intentionally
     * @return Boolean True if newer version exists. False if:
     *  - no new version or
     *  - if auto, but auto check is disabled or
     *  - if auto, but not yet time to check or
     *  - if update is disabled
     */
    protected function updateCheck($auto=true, $output=false)
    {
        $this->log("Running update check");

        if (empty($this->update_version_url))
        {
            if (($output and !$auto) or $this->verbose) $this->output("Update is disabled - update_version_url is empty");
            return false; // update disabled
        }

        if (is_null($this->update_exists))
        {
            $now = time();

            // If this is an automatic check, make sure it's time to check again
            if ($auto)
            {
                $this->log("Designated as auto-update");

                // If disabled, return false
                if ($this->update_auto <= 0)
                {
                    $this->log("Auto-update is disabled - update_auto <= 0");
                    return false; // auto-update disabled
                }

                // If we haven't checked before, we'll check now
                // Otherwise...
                if (!empty($this->update_last_check))
                {
                    $last_check = strtotime($this->update_last_check);

                    // Make sure last check was a valid time
                    if (empty($last_check) or $last_check < 0)
                    {
                        $this->error('Issue with update_last_check value (' . $this->update_last_check . ')');
                    }

                    // Has it been long enough? If not, we'll return false
                    $seconds_since_last_check = $now - $last_check;
                    if ($seconds_since_last_check < $this->update_auto)
                    {
                        $this->log("Only $seconds_since_last_check seconds since last check.  Configured auto-update is " . $this->update_auto . " seconds");
                        return false; // not yet time to check
                    }
                }
            }

            // curl, get contents at config url
            $curl = $this->getCurl($this->update_version_url, true);
            $update_contents = $this->execCurl($curl);

            // look for version match
            if ($this->update_version_pattern[0] === true)
            {
                $this->update_version_pattern[0] = $this->update_pattern_standard;
            }
            if (!preg_match($this->update_version_pattern[0], $update_contents, $match))
            {
                $this->log($update_contents);
                $this->log($this->update_version_pattern[0]);
                $this->error('Issue with update version check - pattern not found at ' . $this->update_version_url, null, true);
                return false;
            }
            $index = $this->update_version_pattern[1];
            $this->update_version = $match[$index];

            // check if remote version is newer than installed
            $class = get_called_class();
            $this->update_exists = version_compare($class::VERSION, $this->update_version, '<');

            if ($output or $this->verbose)
            {
                if ($this->update_exists)
                {
                    $this->hr('>');
                    $this->output("An update is available: version " . $this->update_version . " (currently installed version is " . $class::VERSION . ")");
                    if ($this->method != 'update')
                    {
                        $this->output(" - Run 'update' to install latest version.");
                        $this->output(" - See 'help update' for more information.");
                    }
                    $this->hr('>');
                }
                else
                {
                    $this->output("Already at latest version (" . $class::VERSION . ")");
                }
            }

            // look for download match
            if ($this->update_download_pattern[0] === true)
            {
                $this->update_download_pattern[0] = $this->update_pattern_standard;
            }
            if (!preg_match($this->update_download_pattern[0], $update_contents, $match))
            {
                $this->error('Issue with update download check - pattern not found at ' . $this->update_version_url, null, true);
                return false;
            }
            $index = $this->update_download_pattern[1];
            $this->update_url = $match[$index];

            if ($this->update_check_hash)
            {
                // look for hash algorithm match
                if ($this->update_hash_algorithm_pattern[0] === true)
                {
                    $this->update_hash_algorithm_pattern[0] = $this->hash_pattern_standard;
                }
                if (!preg_match($this->update_hash_algorithm_pattern[0], $update_contents, $match))
                {
                    $this->error('Issue with update hash algorithm check - pattern not found at ' . $this->update_version_url);
                }
                $index = $this->update_hash_algorithm_pattern[1];
                $this->update_hash_algorithm = $match[$index];

                // look for hash match
                if ($this->update_hash_pattern[0] === true)
                {
                    $this->update_hash_pattern[0] = $this->hash_pattern_standard;
                }
                if (!preg_match($this->update_hash_pattern[0], $update_contents, $match))
                {
                    $this->error('Issue with update hash check - pattern not found at ' . $this->update_version_url);
                }
                $index = $this->update_hash_pattern[1];
                $this->update_hash = $match[$index];
            }

            $this->configure('update_last_check', gmdate('Y-m-d H:i:s T', $now), true);
            $this->saveConfig();
        }

        $this->log(" -- update_exists: " . $this->update_exists);
        $this->log(" -- update_version: " . $this->update_version);
        $this->log(" -- update_url: " . $this->update_url);
        $this->log(" -- update_hash_algorithm: " . $this->update_hash_algorithm);
        $this->log(" -- update_hash: " . $this->update_hash);

        return $this->update_exists;
    }

    /**
     * Clear - clear the CLI output
     */
    public function clear()
    {
        system('clear');
    }

    /**
     * Exec - run bash command
     *  - run a command
     *  - return the output
     * @param $error - if true, throw error on bad return
     */
    public function exec($command, $error=false)
    {
        $this->log("exec: $command");
        exec($command, $output, $return);
        $output = empty($output) ? "" : "\n\t" . implode("\n\t", $output);
        if ($return)
        {
            $output = empty($output) ? $return : $output;
            if ($error)
            {
                $this->error($output);
            }
            else
            {
                $this->warn($output);
            }
        }
        $this->log($output);
        return $output;
    }

	/**
	 * Error output
     * 
     * Code Guidelines:
     *  - 100 - expected error - eg. aborted due to user input
     *  - 200 - safety / caution error (eg. running as root)
     *  - 500 - misc. error
	 */
	public function error($data, $code=500, $prompt_to_continue=false)
	{
        $this->br();
        $this->hr('!');
		$this->output('ERROR: ', false);
		$this->output($data);
        $this->hr('!');
		if ($code)
		{
			exit($code);
		}

        if ($prompt_to_continue)
        {
            $yn = $this->input("Continue? (y/n)", 'n', false, true);
            if (!in_array($yn, ['y', 'Y']))
            {
                $this->error('Aborted', 100);
            }
        }
	}

	/**
	 * Warn output
     * @param $data to output as warning
     * @param $prompt_to_continue - whether to prompt with Continue? y/n
	 */
	public function warn($data, $prompt_to_continue=false)
	{
        $this->br();
        $this->hr('*');
		$this->output('WARNING: ', false);
		$this->output($data, true, false);
        $this->hr('*');

        if ($prompt_to_continue)
        {
            $this->log("Getting input to continue");
            $yn = $this->input("Continue? (y/n)", 'n', false, true);
            if (!in_array($yn, ['y', 'Y']))
            {
                $this->error('Aborted', 100);
            }
        }

	}

    /**
     * Logging output - only when verbose=true
     */
    public function log($data)
    {
        if (!$this->verbose) return;
        
        $this->output($data);
    }

    /**
     * Output data
     */
    public function output($data, $line_ending=true, $stamp_lines=null)
    {
        $data = $this->stringify($data);

        $stamp_lines = is_null($stamp_lines) ? $this->stamp_lines : $stamp_lines;
		if ($stamp_lines)
			echo $this->stamp() . ' ... ';

		echo $data . ($line_ending ? "\n" : "");
    }

    /**
     * Progress Bar Output
     */
    public function outputProgress($count, $total, $description = "remaining")
    {
        if (!$this->verbose)
        {
            if ($count > 0)
            {
                // Set cursor to first column
                echo chr(27) . "[0G";
                // Set cursor up 2 lines
                echo chr(27) . "[2A";
            }

            $full_width = $this->getTerminalWidth();
            $pad = $full_width - 1;
            $bar_count = floor(($count * $pad) / $total);
            $output = "[";
            $output = str_pad($output, $bar_count, "|");
            $output = str_pad($output, $pad, " ");
            $output.= "]";
            $this->output($output);
            $this->output(str_pad("$count/$total", $full_width, " ", STR_PAD_LEFT));
        }
        else
        {
            $this->output("$count/$total $description");
        }
    }

    /**
     * Stringify some data for output
     */
    public function stringify($data)
    {
        if (is_object($data) or is_array($data))
        {
            $data = print_r($data, true);
        }
        else if (is_bool($data))
        {
            $data = $data ? "(Bool) True" : "(Bool) False";
        }
        elseif (is_null($data))
        {
            $data = "(NULL)";
        }
        elseif (is_int($data))
        {
            $data = "(int) $data";
        }
        else if (!is_string($data))
        {
            ob_start();
            var_dump($data);
            $data = ob_get_clean();
        }
        // Trimming breaks areas where we *want* extra white space
        // - must be done explicitly instead, or modify to pass in as an option maybe...
        // $data = trim($data, " \t\n\r\0\x0B");
        return $data;
    }

    /**
     * Colorize a string for output to console
     *  - https://en.wikipedia.org/wiki/ANSI_escape_code
     */
    public function colorize($string, $foreground=null, $background=null, $other=[])
    {
        if (empty($foreground) and empty($background) and empty($other)) return $string;

        $colored_string = "";
        $colored = false;

        foreach (['foreground', 'background', 'other'] as $type)
        {
            if (!is_null($$type))
            {
                if (!is_array($$type))
                {
                    $$type = [$$type];
                }

                foreach ($$type as $value_name)
                {
                    if (isset(CONSOLE_COLORS::$$type[$value_name]))
                    {
                        $colored_string .= "\033[" . CONSOLE_COLORS::$$type[$value_name] . "m";
                        $colored = true;
                    }
                    else
                    {
                        $this->warn("Invalid '$type' color specification - " . $value_name);
                    }
                }
            }
        }

        $colored_string.= $string;

        if ($colored)
        {
            $colored_string.="\033[0m";
        }

        return $colored_string;
    }

    /**
     * Output 3 Columns - for help for example
     */
    public function output3col($col1, $col2=null, $col3=null)
    {
        $full_width = $this->getTerminalWidth();
        $col1_width = floor(($full_width * static::COL1_WIDTH) / 100);
        $col2_width = floor(($full_width * static::COL2_WIDTH) / 100);

        $string = str_pad($col1, $col1_width, " ");
        if (!is_null($col2))
        {
            $string.= "| " . $col2;
        }
        if (!is_null($col3))
        {
            $string = str_pad($string, $col2_width, " ") . "| " . $col3;
        }
        $string = str_pad("| $string", $full_width-1) . "|";
        $this->output($string);
    }

    /**
     * Output break
     */
    public function br()
    {
        $this->output('');
    }

    /**
     * br, but only if logging is on
     */
    public function brl()
    {
        if (!$this->verbose) return;

        $this->br;
    }
    /**
     * Output horizonal line - divider
     */
    public function hr($c='=', $prefix="")
    {
        $string = str_pad($prefix, $this->getTerminalWidth(), $c);
        $this->output($string);
    }
    /**
     * hr, but only if logging is on
     */
    public function hrl($c='=', $prefix="")
    {
        if (!$this->verbose) return;

        $this->hr($c, $prefix);
    }


    /**
     * Pause during output for debugging/stepthrough
     */
    public function pause($message="[ ENTER TO STEP | 'FINISH' TO CONTINUE ]")
    {
        if (!$this->step) return;

        $this->hr();
        $this->output($message);
        $this->hr();

        $line = $this->input();

        if (strtolower(trim($line)) == 'finish')
        {
            $this->step = false;
        }
    }

    /**
     * Sleep for set time, with countdown
     * @param $seconds - number of seconds to wait
     * @param $message - formatted string
     */
    public function sleep($seconds=3, $message="Continuing in %s...")
    {
        $seconds = (int) $seconds;
        $max_pad = 0;
        while ($seconds > 0)
        {
            $output = sprintf($message, $seconds);
            $pad = strlen($output);
            if ($pad < $max_pad)
            {
                $output = str_pad($output, $max_pad);
            }
            else
            {
                $max_pad = $pad;
            }

            echo $output;
            sleep(1);
            $seconds-=1;
            echo "\r";
        }
        echo str_pad("", $max_pad);
        echo "\n";
    }

    /**
     * Get selection from list - from CLI
     * @param (array) $list of items to pick from
     * @param (any) $message (none) to show - prompt
     * @param (int) $default (0) index if no input
     */
    public function select($list, $message=false,$default=0,$q_to_quit=true)
    {
        $list = array_values($list);
        foreach ($list as $i => $item)
        {
            $this->output("$i. $item");
        }

        if ($q_to_quit)
        {
            $this->output("q. Quit and exit");
        }

        $max = count($list)-1;
        $index=-1;
        $entry=false;

        while ($index < 0 or $index > $max)
        {
            if ($entry !== false)
            {
                $this->warn("Invalid selection $entry");
            }
            $this->output("Enter number or part of selection");
            $entry = $this->input($message, $default);
            if ($q_to_quit and (strtolower(trim($entry)) == 'q'))
            {
                $this->warn('Selection Canceled');
                exit;
            }

            if (!is_numeric($entry))
            {
                $filtered_items = [];

                foreach ($list as $item)
                {
                    if (stripos($item, $entry) !== false)
                    {
                        $filtered_items[] = $item;
                    }
                }

                if (count($filtered_items) == 1)
                {
                    return $filtered_items[0];
                }
                elseif (!empty($filtered_items))
                {
                    return $this->select($filtered_items, $message, 0, $q_to_quit);
                }
            }

            // Make sure it's really a good entry
            // Eg. avoid 1.2 => 1 or j => 0
            //  - which would result in unwanted behavior for bad entries
            $index = (int) $entry;
            if ((string) $entry !== (string) $index)
            {
                $index = -1;
            }
        }

        return $list[$index];
    }

    /**
     * Confirm yes/no
     * @param Same params as input - see descriptions there
     * @return (bool) true/false
     */
    public function confirm($message, $default='y', $required=false, $single=true, $single_hide=false)
    {
        $yn = $this->input($message, $default, $required, $single, $single_hide);

        // True if first letter of response is y or Y
        return strtolower(substr($yn,0,1)) == 'y';
    }

    /**
     * Edit some text in external editor
     * @param $text to edit
     */
    public function edit($text="", $filename=null, $modify=false)
    {
        if (is_null($filename))
        {
            $filename = "edit_" . date("YmdHis") . ".txt";
        }
        $filepath = $this->setTempContents($filename, $text);

        $command = sprintf( ($modify ? $this->editor_modify_exec : $this->editor_exec), $filepath);
        $this->exec($command, true);

        return $this->getTempContents($filename);
    }

    /**
     * Get input from CLI
     * @param $message to show - prompt
     * @param $default if no input
     * @param $required - wether input is required
     * @param $single - prompt for single character (vs waiting for enter key)
     * @param $single_hide - hide input for single character (is this working?)
     * @return input text or default
     */
    public function input($message=false, $default=null, $required=false, $single=false, $single_hide=false)
    {
        if ($message)
        {
            if ($message === true) $message = "";

            if (!is_null($default))
            {
                $message.= " ($default)";
            }
            $message.= ": ";
        }

        while (true)
        {
            if ($message) $this->output($message, false);
            if ($single)
            {
                $single_hide = $single_hide ? ' -s' : '';
                if ($this->is_windows)
                {
                    $line = trim( `bash -c "read$single_hide -n1 CHAR && echo \$CHAR"` );
                }
                else
                {
                    $line = trim( `bash -c 'read$single_hide -n1 CHAR && echo \$CHAR'` );
                }
            }
            else
            {
                $handle = $this->getCliInputHandle();
                $line = fgets($handle);
            }
            $line = trim($line);

            // Entered input - return
            if ($line !== "") return $line;

            // Input not required? Return default
            if (!$required) return $default;

            // otherwise, warn, loop and try again
            $this->warn("Input required - please try again");
        }


    }

    /**
     * Get timestamp
     */
    public function stamp()
    {
        return date('Y-m-d_H.i.s');
    }

    /**
     * Get Config Dir
     */
    public function getConfigDir()
    {
        if (is_null($this->config_dir))
        {
            $this->config_dir = $this->getHomeDir() . DS . '.' . static::SHORTNAME;
        }

        return $this->config_dir;
    }

    /**
     * Get Config File
     */
    public function getConfigFile()
    {
        if (is_null($this->config_file))
        {
            $config_dir = $this->getConfigDir();
            $this->config_file = $config_dir . DS . 'config.hjson';
        }

        return $this->config_file;
    }

    /**
     * Get Home Directory
     */
    public function getHomeDir()
    {
        if (is_null($this->home_dir))
        {
            $return_error = false;

            $sudo_user = "";
            if ($this->running_as_root)
            {
                // Check if run via sudo vs. natively running as root
                exec('echo "$SUDO_USER"', $output, $return_error);
                if (!$return_error and !empty($output))
                {
                    $sudo_user = trim(array_pop($output));
                }
            }

            // Not Sudo User?
            if (empty($sudo_user))
            {
                // Windows doesn't have 'HOME' set necessarily
                if (empty($_SERVER['HOME']))
                {
                    $this->home_dir = $_SERVER['HOMEDRIVE'] . $_SERVER['HOMEDRIVE'];
                }
                // Simplest and most typical - get home dir from env vars.
                else
                {
                    $this->home_dir = $_SERVER['HOME'];
                }
            }
            else // Running via sudo - get home dir of sudo user (if not root)
            {
                exec('echo ~' . $sudo_user, $output, $return_error);

                if (!$return_error and !empty($output))
                {
                    $this->home_dir = trim(array_pop($output));
                }
            }

            if (empty($this->home_dir))
            {
                $this->error('Something odd about this environment... can\'t figure out your home directory; please submit an issue with details about your environment');
            }
            else if (!is_dir($this->home_dir))
            {
                $this->error('Something odd about this environment... home directory looks like "'.$this->home_dir.'" but that is not a directory; please submit an issue with details about your environment');
            }

        }

        return $this->home_dir;
    }

    /**
     * Init/Load Config File
     */
    public function initConfig()
    {
        $config_file = $this->getConfigFile();

        $this->backup_dir = $this->getConfigDir() . DS . 'backups';

        try
        {
            // Move old json file to hjson if needed
            if (!is_file($config_file))
            {
                $old_json_config_file = str_ireplace('.hjson', '.json', $config_file);
                if (is_file($old_json_config_file))
                {
                    if ( ! rename($old_json_config_file, $config_file) )
                    {
                        $this->warn("Old json config file found, but couldn't rename it.\nTo keep your config settings, move '$old_json_config_file' to '$config_file'.\nIf you continue now, a new config file will be created with default values at '$config_file'.", true);
                    }
                }
            }

            // Loading specific config values from file
            if (is_file($config_file))
            {
                // $this->log("Loading config file - $config_file");
                $json = file_get_contents($config_file);
                $config = $this->json_decode($json, true);
                if (empty($config))
                {
                    $this->error("Likely syntax error: $config_file");
                }
                foreach ($config as $key => $value)
                {
                    $this->configure($key, $value);
                }
            }

            // Setting config to save, based on current values
            $this->config_to_save = [];
            foreach ($this->getPublicProperties() as $property)
            {
                $this->config_to_save[$property] = $this->$property;
            }
            ksort($this->config_to_save);

            $this->config_initialized = true;

            $this->saveConfig();
        }
        catch (Exception $e)
        {
            // Notify user
            $this->output('NOTICE: ' . $e->getMessage());
        }
    }

    /**
     * Save config values to file on demand
     */
    public function saveConfig()
    {
        if (!$this->config_initialized)
        {
            $this->warn('Config not initialized, refusing to save', true);
            return false;
        }

        $config_dir = $this->getConfigDir();
        $config_file = $this->getConfigFile();

        try
        {
            if (!is_dir($config_dir))
            {
                // $this->log("Creating directory - $config_dir");
                mkdir($config_dir, 0755);
            }

            // Update comments in config data
            if (empty($this->config_to_save['__WSC__']))
            {
                $this->config_to_save['__WSC__'] = [];
                $this->config_to_save['__WSC__']['c'] = [];
                $this->config_to_save['__WSC__']['o'] = [];
            }

            $this->config_to_save['__WSC__']['c'][" "] = "\n    /**\n     * " . $this->version(false) . " configuration\n     */\n";
            foreach ($this->config_to_save as $key => $value)
            {
                if ($key != '__WSC__')
                {
                    $help = $this->_help_var($key, 'option');
                    if (empty($help)) continue;

                    $help = $this->_help_param($help);
                    $type = $help[1];
                    $info = $help[0];
                    
                    $value = " // ($type) $info";
                }

                $this->config_to_save['__WSC__']['c'][$key] = $value;
            }

            // Rewrite config file
            $json = $this->json_encode($this->config_to_save);
            file_put_contents($config_file, $json);

            // Fix permissions if needed
            if ($this->running_as_root and !$this->logged_in_as_root)
            {
                $success = true;
                $success = ($success and chown($config_dir, $this->logged_in_user));
                $success = ($success and chown($config_file, $this->logged_in_user));

                if (!$success)
                {
                    $this->warn("There may have been an issue setting correct permissions on the config directory ($config_dir) or file ($config_file).  Review these permissions manually.", true);
                }
            }
        }
        catch (Exception $e)
        {
            // Notify user
            $this->output('NOTICE: ' . $e->getMessage());
        }
    }

    /**
     * Prepare shell argument for use
     * @param $value to prep
     * @param $default to return if $value is empty
     * @param $force_type - whether to force a type for return value: 
     *  'array': split and/or wrap to force it to be an array
     *  'boolean': parse as boolean (1/true/yes).
     * Note: defaults to 'array' if $default is an array
     * @param $trim (true) - whether to trim whitespace from value(s)
     */
    public function prepArg($value, $default, $force_type=null, $trim=true)
    {
        $a = func_num_args();
        if ($a < 2) $this->error('prepArg requires value & default');

        if (is_null($force_type))
        {
            if (is_array($default))
            {
                $force_type = 'array';
            }
        }

        if ($force_type == 'bool')
        {
            $force_type = 'boolean';
        }

        // For backwards compatibility
        if ($force_type === true)
        {
            $force_type = 'array';
        }

        // Default?
        if (empty($value))
        {
            $value = $default;
        }

        // Change to array if needed
        if (is_string($value) and $force_type=='array')
        {
            $value = explode(",", $value);
        }

        // Trim
        if ($trim)
        {
            if (is_string($value))
            {
                $value = trim($value);
            }
            else if (is_array($value))
            {
                if (isset($value[0]) and is_string($value[0]))
                {
                    $value = array_map('trim', $value);
                }
            }
        }

        if ($force_type == 'boolean')
        {
            $value = in_array($value, [true, 'true', 'yes', '1', 1]);
        }

        return $value;
    }

    /**
     * Open link in browser
     */
    public function openInBrowser($url)
    {
        $command = sprintf($this->browser_exec, $url);
        $this->exec($command, true);
    }

    /**
     * Configure property - if public
     */
    public function configure($key, $value, $save_value=false)
    {
        $key = str_replace('-', '_', $key);

        if (substr($key, 0, 3) == 'no_' and $value === true)
        {
            $key = substr($key, 3);
            $value = false;
        }

        $public_properties = $this->getPublicProperties();
        if (in_array($key, $public_properties))
        {

            if (is_string($value))
            {
                $value = preg_replace('/^\~/', $this->getHomeDir(), $value);
            }

            $this->{$key} = $value;

            if ($save_value)
            {
                $this->config_to_save[$key] = $value;
            }
        }
        else
        {
            $this->output("NOTICE: invalid config key - $key");
        }
    }

    // Get basic curl
    public function getCurl($url, $fresh_no_cache=false)
    {
        if (!$this->ssl_check)
        {
            $this->warn("Initializing unsafe connection to $url (no SSL check, as configured)", true);
        }

        $curl = curl_init();
        curl_setopt_array($curl, [
            CURLOPT_URL => $url,
            CURLOPT_HEADER => false,
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_CONNECTTIMEOUT => 0,
            CURLOPT_TIMEOUT => 180,
            CURLOPT_FOLLOWLOCATION => true,
            CURLOPT_SSL_VERIFYHOST => ($this->ssl_check ? 2 : 0),
            CURLOPT_SSL_VERIFYPEER => ($this->ssl_check ? 2 : 0),
        ]);

        if ($fresh_no_cache)
        {
            curl_setopt($curl, CURLOPT_FRESH_CONNECT, true);
        }

        return $curl;
    }

    // Exec curl and handle errors, return response if good
    public function execCurl($curl)
    {
        $response = curl_exec($curl);

        if (empty($response))
        {
            $number = curl_errno($curl);

            // Was there an error?
            if ($number)
            {
                $message = curl_error($curl);

                if (stripos($message, 'ssl') !== false)
                {
                    $message.= "\n\nFor some SSL issues, try downloading the latest CA bundle and pointing your PHP.ini to that (https://curl.haxx.se/docs/caextract.html)";
                    $message.= "\n\nAlthough risky and not recommended, you can also consider re-running your command with the --no-ssl-check flag";
                }

                $this->warn($message, true);
            }
        }

        return $response;
    }

    // Update arguments for curl URL
    public function updateCurlArgs($ch, $args, $overwrite=false)
    {
        // Get info from previous curl
        $curl_info = curl_getinfo($ch);

        // Parse out URL and query params
        $url = $curl_info['url'];

        $url_parsed = parse_url($url);
        if (empty($url_parsed['query']))
        {
            $query = [];
        }
        else
        {
            parse_str($url_parsed['query'], $query);
        }

        // Set new args
        foreach ($args as $key=>$value)
        {
            if (!isset($query[$key]) or $overwrite)
            {
                $query[$key] = $value;
            }
        }

        // Build new URL
        $new_url =
            $url_parsed['scheme'] .
            "://" .
            $url_parsed['host'] .
            $url_parsed['path'] .
            "?" .
            http_build_query($query);
        $this->log($new_url);
        curl_setopt($ch, CURLOPT_URL, $new_url);
    }

    /**
     * Interact with cache files
     */
    public function getCacheContents($subpath, $expiration=null)
    {
        $expiration = $expiration ?? $this->cache_lifetime;

        $config_dir = $this->getConfigDir();
        $cache_dir = $config_dir . DS . 'cache';
        $subpath = is_array($subpath) ? implode(DS, $subpath) : $subpath;

        $cache_file = $cache_dir . DS . $subpath;
        $contents=false;

        if (is_file($cache_file))
        {
            $this->log("Cache file exists ($cache_file) - checking age");
            $cache_modified = filemtime($cache_file);
            $now = time();
            $cache_age = $now - $cache_modified;
            if ($cache_age < $expiration)
            {
                $this->log("New enough - reading from cache file ($cache_file)");
                $contents = file_get_contents($cache_file);
                if ($contents === false)
                {
                    $this->warn("Failed to read cache file ($cache_file) - possible permissions issue", true);
                }
            }
        }

        return $contents;
    }
    public function setCacheContents($subpath, $contents)
    {
        $config_dir = $this->getConfigDir();
        $cache_dir = $config_dir . DS . 'cache';
        $subpath = is_array($subpath) ? implode(DS, $subpath) : $subpath;

        $cache_file = $cache_dir . DS . $subpath;
        $cache_dir = dirname($cache_file);

        if (!is_dir($cache_dir))
        {
            mkdir($cache_dir, 0755, true);
        }

        $written = file_put_contents($cache_file, $contents);
        if ($written === false)
        {
            $this->warn("Failed to write to cache file ($cache_file) - possible permissions issue", true);
            return false;
        }

        return $cache_file;
    }

    /**
     * Interact with temp files
     */
    public function getTempContents($subpath)
    {
        $config_dir = $this->getConfigDir();
        $temp_dir = $config_dir . DS . 'temp';
        $subpath = is_array($subpath) ? implode(DS, $subpath) : $subpath;

        $temp_file = $temp_dir . DS . $subpath;
        $contents=false;

        if (is_file($temp_file))
        {
            $this->log("Temp file exists ($temp_file) - reading from temp file");
            $contents = file_get_contents($temp_file);
            if ($contents === false)
            {
                $this->warn("Failed to read temp file ($temp_file) - possible permissions issue", true);
            }
        }

        return $contents;
    }
    public function setTempContents($subpath, $contents)
    {
        $config_dir = $this->getConfigDir();
        $temp_dir = $config_dir . DS . 'temp';
        $subpath = is_array($subpath) ? implode(DS, $subpath) : $subpath;

        $temp_file = $temp_dir . DS . $subpath;
        $temp_dir = dirname($temp_file);

        if (!is_dir($temp_dir))
        {
            mkdir($temp_dir, 0755, true);
        }

        $written = file_put_contents($temp_file, $contents);
        if ($written === false)
        {
            $this->warn("Failed to write to temp file ($temp_file) - possible permissions issue", true);
            return false;
        }

        return $temp_file;
    }

    /**
     * Paginate some content for display on terminal
     */
    public function paginate($content, $options=[])
    {
        $options = array_merge([
            'starting_line' => 1,
            'starting_column' => 1, // todo
            'wrap' => false,
            'line_buffer' => 1,
            'output' => true,
            'include_page_info' => true,
            'fill_height' => true,
        ], $options);

        // Split into lines if needed
        if (is_string($content))
        {
            $content = preg_split("/\r\n|\n|\r/", $content);
        }

        $max_width = $this->getTerminalWidth();

        $max_height = $this->getTerminalHeight();
        $max_height = $max_height - $options['line_buffer'];
        $max_height = $max_height - 2; // for start/end line breaks
        if ($options['include_page_info'])
        {
            $max_height = $max_height - 2; // for page info and extra line break
        }

        if (!is_array($content)) $content = explode("\n");
        $content = array_values($content);

        // Pre-wrap lines if specified, to make sure pagination works based on real number of lines
        if ($options['wrap'])
        {
            $wrapped_content = [];
            foreach ($content as $line)
            {
                while (strlen($line) > $max_width)
                {
                    $wrapped_content[]= substr($line, 0, $max_width);
                    $line = substr($line, $max_width);
                }
                $wrapped_content[]= $line;
            }
            $content = $wrapped_content;
        }

        $content_length = count($content);

        $are_prev = false;
        if ($options['starting_line'] > 1)
        {
            $are_prev = true;
        }

        $are_next = false;
        if (($options['starting_line'] + $max_height - 1) < $content_length)
        {
            $are_next = true;
        }

        $height = 0;
        $output = [];

        // Starting line break
        if ($are_prev)
        {
            $output[]= $this->colorize(str_pad("==[MORE ABOVE]", $max_width, "="), 'green', null, 'bold');
        }
        else
        {
            $output[]= str_pad("", $max_width, "=");
        }

        $l = $options['starting_line'] - 1;
        $final_line = $options['starting_line'];
        while ($height < $max_height)
        {
            if ($l < ($content_length))
            {
                $final_line = $l + 1;
                $line = $content[$l];
            }
            else
            {
                if ($options['fill_height'])
                {
                    $line = "";
                }
                else
                {
                    break;
                }
            }


            if (!is_string($line)) $this->error("Bad type for line $l of content - string expected");
            if (strlen($line) > $max_width)
            {
                if ($options['wrap'])
                {
                    $this->error("Something wrong with the following line - wrap was on, but it's still too long", false);
                    $this->output($line);
                    $this->error("Aborting");
                }

                $line = substr($line, 0, $max_width);
            }
            $output[]= $line;

            $l++;
            $height++;
        }

        // Ending line break
        if ($are_next)
        {
            $output[]= $this->colorize(str_pad("==[MORE BELOW]", $max_width, "="), 'green', null, 'bold');
        }
        else
        {
            $output[]= str_pad("", $max_width, "=");
        }

        if ($options['include_page_info'])
        {
            $output[]= str_pad($options['starting_line'] . " - " . $final_line . " of " . $content_length . " items", $max_width, " ");
            $output[]= str_pad("", $max_width, "=");
        }

        $output = implode("\n", $output);

        if ($options['output'])
        {
            echo $output;
        }

        return [
            'output' => $output,
            'starting_line' => $options['starting_line'],
            'page_length' => $max_height,
            'ending_line' => min(($options['starting_line'] + $max_height) - 1, $content_length),
        ];
    }

    /**
     * Get parameters for a given method
     */
    protected function _getMethodParams($method)
    {
        $r = new ReflectionObject($this);
        $rm = $r->getMethod($method);
        $params = [];
        foreach ($rm->getParameters() as $param)
        {
            $params[]=$param->name;
        }
        return $params;
    }

    // Manage Properties
    protected $_public_properties = null;
    public function getPublicProperties()
    {
        if (is_null($this->_public_properties))
        {
            $this->_public_properties = [];
            $reflection = new ReflectionObject($this);
            foreach ($reflection->getProperties(ReflectionProperty::IS_PUBLIC) as $prop)
            {
                $this->_public_properties[]= $prop->getName();
            }
            sort($this->_public_properties);
        }

        return $this->_public_properties;

    }

    // Manage CLI Input Handle
    protected $_cli_input_handle = null;
    protected function getCliInputHandle()
    {
        if (is_null($this->_cli_input_handle))
        {
            $this->_cli_input_handle = fopen ("php://stdin","r");
        }

        return $this->_cli_input_handle;
    }
    protected function close_cli_input_handle()
    {
        if (!is_null($this->_cli_input_handle))
        {
            fclose($this->_cli_input_handle);
        }
    }

    protected $_terminal_height = null;
    public function getTerminalHeight($fresh=false)
    {
        if (is_null($this->_terminal_height))
        {
            exec("tput lines", $output, $return);

            if (
                $return
                or empty($output)
                or empty($output[0])
                or !is_numeric($output[0])
            ){
                $this->_terminal_height = static::DEFAULT_HEIGHT;
            }
            else
            {
                $this->_terminal_height = (int) $output[0];
            }
        }

        return $this->_terminal_height;
    }

    protected $_terminal_width = null;
    public function getTerminalWidth($fresh=false)
    {
        if (is_null($this->_terminal_width))
        {
            exec("tput cols", $output, $return);

            if (
                $return
                or empty($output)
                or empty($output[0])
                or !is_numeric($output[0])
            ){
                $this->_terminal_width = static::DEFAULT_WIDTH;
            }
            else
            {
                $this->_terminal_width = (int) $output[0];
            }
        }

        return $this->_terminal_width;
    }

    /**
     * Parse HTML for output to terminal
     * Supporting:
     *  - Bold
     *  - Italic (showing as dim)
     *  - Links (Underlined with link in parentheses)
     *  - Unordered Lists ( - )
     *  - Ordered Lists ( 1. ) 
     *  - Hierarchical lists (via indentation)
     * Not Yet:
     *  - Text colors
     *  - Underline styles
     *  - Indentation styles
     *  - Less commonly supported terminal styles
     */
    public function parseHtmlForTerminal($dom, $depth=0, $prefix="")
    {
        $output = "";

        if (is_string($dom))
        {
            // Deal with odd UTF8 characters that sneak in sometimes
            $dom = utf8_decode($dom);

            $tmp = new DOMDocument();
            if (! @$tmp->loadHTML(trim($dom)))
            {
                return $dom;

                var_dump($dom);
                $this->error("Failed to parse HTML");
            }
            $dom = $tmp;
        }

        if (!is_object($dom) or !in_array(get_class($dom), ["DOMDocumentType", "DOMDocument", "DOMElement"]))
        {
            $type = is_object($dom) ? get_class($dom) : gettype($dom);
            $this->error("Invalid type passed to parseHtmlForTerminal - $type");
        }
         
        foreach ($dom->childNodes as $child_index => $node)
        {
            $_output = ""; // output for this child
            $_prefix = $prefix; // prefix for this child's children - start with current prefix, passed to function
            $_suffix = ""; // suffix for end of this child

            // Note coloring if needed
            $color_foreground = null;
            $color_background = null;
            $color_other = null;

            switch($node->nodeName)
            {
                case 'a':
                    $color_other = 'underline';
                    $href = trim($node->getAttribute('href'));
                    $content = trim($node->nodeValue);
                    if (strtolower(trim($href,"/")) != strtolower(trim($content,"/")))
                    {
                        $_suffix = " [$href]";
                    }
                    break;

                case 'br':
                case 'p':
                    $_output.= "\n" . $_prefix;
                    break;

                case 'b':
                case 'strong':
                    $color_other = 'bold';
                    break;

                case 'em':
                    $color_other = 'dim';
                    break;
            
                case 'ol':
                case 'ul':
                    $_output.="\n";
                    break;

                case 'li':

                    // Output number for ol child, otherwise, default to "-"
                    $list_char = " - ";
                    if ($dom->nodeName == "ol")
                    {
                        $list_char = " " . ($child_index + 1) . ". ";
                    }

                    $_output.= $_prefix . $list_char;

                    // Update prefix for child elements
                    $_prefix = $_prefix . str_pad("", strlen($list_char));

                    $_suffix = "\n";

                    break;

                case '#text':
                    $_output.= $node->nodeValue;
                    break;

                default:
                    break;
            }

            // Output for Debugging
            if ($this->verbose)
            {
                $this->log(str_pad("", $depth*2) . $node->nodeName.':"'.$node->nodeValue.'"');

                $_output.="[" . $node->nodeName . "]";
            }

            if ($node->hasChildNodes())
            {
                $_output.= $this->parseHtmlForTerminal($node, $depth+1, $_prefix);
            }

            if ($this->verbose)
            {
                // For Debugging
                $_output.="[/" . $node->nodeName . "]";
            }

            // Decorate the output as needed
            $_output = $this->colorize($_output, $color_foreground, $color_background, $color_other);
            
            $output.= $_output . $_suffix;
        }

        //$output = str_replace("\u{00a0}", " ", $output);
        $output = str_replace("\r", "\n", $output);
        $output = preg_replace('/\n(\s*\n){2,}/', "\n\n", $output);

        return htmlspecialchars_decode($output);
    }

    /**
     * Parse Markdown to HTML
     * - uses Parsedown
     * - uses some defaults based on common use
     * - alternatively, can call Parsedown directly
     */
    public function parseMarkdownToHtml($text)
    {
        $html = Parsedown::instance()
            ->setBreaksEnabled(true)
            ->setMarkupEscaped(true)
            ->setUrlsLinked(false)
            ->text($text);
        return $html;
    }

    /**
     * JSON encode & decode, using HJSON
     */
    public function json_decode($json, $options=[])
    {
        $this->log("Running json_decode on console_abstract");

        // mimic json_decode behavior
        if ($options === true)
        {
            $options = ['assoc' => true];
        }

        // default to preserve comments and whitespace
        if (!isset($options['keepWsc']))
        {
            $options['keepWsc'] = true;
        }

        $parser = new HJSONParser;
        $data = $parser->parse($json, $options);
        $this->_json_cleanup($data);
        return $data;
    }
    public function json_encode($data, $options=[])
    {
        $this->log("Running json_encode on console_abstract");

        $options = array_merge([
            'keepWsc' => true,
            'bracesSameLine' => true,
            'quotes' => 'always',
            'space' => 4,
            'eol' => PHP_EOL,
        ], $options);

        // default to preserve comments and whitespace
        if (!isset($options['keepWsc']))
        {
            $options['keepWsc'] = true;
        }

        if (empty($options['keepWsc']))
        {
            unset($data['__WSC__']);
        }
        else
        {
            if (!empty($data['__WSC__']))
            {
                $data['__WSC__'] = (object) $data['__WSC__'];
                if (!empty($data['__WSC__']->c))
                {
                    $data['__WSC__']->c = (object) $data['__WSC__']->c;
                }
            }
        }

        $this->_json_cleanup($data);

        $stringifier = new HJSONStringifier;
        $json = $stringifier->stringify($data, $options);
        return $json;
    }
    protected function _json_cleanup(&$data)
    {
        if (is_iterable($data))
        {
            foreach ($data as $key => &$value)
            {
                if (is_object($value))
                {
                    unset($value->__WSC__);
                }
                if (is_array($value))
                {
                    unset($value['__WSC__']);
                }

                $this->_json_cleanup($value);
            }
        }
    }

    // Prevent infinite loop of magic method handling
    public function __call($method, $arguments)
    {
        throw new Exception("Invalid method '$method'");
    }
}

// For working locally
if (!empty($src_includes) and is_array($src_includes))
{
    foreach ($src_includes as $src_include)
    {
        require_once ($src_include);
    }
}

// Note: leave this for packaging ?>
<?php
$CONFIG_KEYS = [
	"addkeystoagent" => "AddKeysToAgent",
	"addressfamily" => "AddressFamily",
	"batchmode" => "BatchMode",
	"bindaddress" => "BindAddress",
	"canonicaldomains" => "CanonicalDomains",
	"canonicalizefallbacklocal" => "CanonicalizeFallbackLocal",
	"canonicalizehostname" => "CanonicalizeHostname",
	"canonicalizemaxdots" => "CanonicalizeMaxDots",
	"canonicalizepermittedcnames" => "CanonicalizePermittedCNAMEs",
	"casignaturealgorithms" => "CASignatureAlgorithms",
	"certificatefile" => "CertificateFile",
	"challengeresponseauthentication" => "ChallengeResponseAuthentication",
	"checkhostip" => "CheckHostIP",
	"ciphers" => "Ciphers",
	"clearallforwardings" => "ClearAllForwardings",
	"compression" => "Compression",
	"connectionattempts" => "ConnectionAttempts",
	"connecttimeout" => "ConnectTimeout",
	"controlmaster" => "ControlMaster",
	"controlpath" => "ControlPath",
	"controlpersist" => "ControlPersist",
	"dynamicforward" => "DynamicForward",
	"escapechar" => "EscapeChar",
	"exitonforwardfailure" => "ExitOnForwardFailure",
	"fingerprinthash" => "FingerprintHash",
	"forwardagent" => "ForwardAgent",
	"forwardx11" => "ForwardX11",
	"forwardx11timeout" => "ForwardX11Timeout",
	"forwardx11trusted" => "ForwardX11Trusted",
	"gatewayports" => "GatewayPorts",
	"globalknownhostsfile" => "GlobalKnownHostsFile",
	"gssapiauthentication" => "GSSAPIAuthentication",
	"gssapikeyexchange" => "GSSAPIKeyExchange",
	"gssapiclientidentity" => "GSSAPIClientIdentity",
	"gssapidelegatecredentials" => "GSSAPIDelegateCredentials",
	"gssapikexalgorithms" => "GSSAPIKexAlgorithms",
	"gssapirenewalforcesrekey" => "GSSAPIRenewalForcesRekey",
	"gssapiserveridentity" => "GSSAPIServerIdentity",
	"gssapitrustdns" => "GSSAPITrustDns",
	"hashknownhosts" => "HashKnownHosts",
	"host" => "Host",
	"hostbasedauthentication" => "HostbasedAuthentication",
	"hostbasedkeytypes" => "HostbasedKeyTypes",
	"hostkeyalgorithms" => "HostKeyAlgorithms",
	"hostkeyalias" => "HostKeyAlias",
	"hostname" => "HostName",
	"identitiesonly" => "IdentitiesOnly",
	"identityagent" => "IdentityAgent",
	"identityfile" => "IdentityFile",
	"ipqos" => "IPQoS",
	"kbdinteractiveauthentication" => "KbdInteractiveAuthentication",
	"kbdinteractivedevices" => "KbdInteractiveDevices",
	"kexalgorithms" => "KexAlgorithms",
	"localcommand" => "LocalCommand",
	"localforward" => "LocalForward",
	"loglevel" => "LogLevel",
	"macs" => "MACs",
	"match" => "Match",
	"nohostauthenticationforlocalhost" => "NoHostAuthenticationForLocalhost",
	"numberofpasswordprompts" => "NumberOfPasswordPrompts",
	"passwordauthentication" => "PasswordAuthentication",
	"permitlocalcommand" => "PermitLocalCommand",
	"pkcs11provider" => "PKCS11Provider",
	"port" => "Port",
	"preferredauthentications" => "PreferredAuthentications",
	"proxycommand" => "ProxyCommand",
	"proxyjump" => "ProxyJump",
	"proxyusefdpass" => "ProxyUseFdpass",
	"pubkeyacceptedkeytypes" => "PubkeyAcceptedKeyTypes",
	"pubkeyauthentication" => "PubkeyAuthentication",
	"rekeylimit" => "RekeyLimit",
	"remotecommand" => "RemoteCommand",
	"remoteforward" => "RemoteForward",
	"requesttty" => "RequestTTY",
	"sendenv" => "SendEnv",
	"serveraliveinterval" => "ServerAliveInterval",
	"serveralivecountmax" => "ServerAliveCountMax",
	"setenv" => "SetEnv",
	"streamlocalbindmask" => "StreamLocalBindMask",
	"streamlocalbindunlink" => "StreamLocalBindUnlink",
	"stricthostkeychecking" => "StrictHostKeyChecking",
	"tcpkeepalive" => "TCPKeepAlive",
	"tunnel" => "Tunnel",
	"tunneldevice" => "TunnelDevice",
	"updatehostkeys" => "UpdateHostKeys",
	"user" => "User",
	"userknownhostsfile" => "UserKnownHostsFile",
	"verifyhostkeydns" => "VerifyHostKeyDNS",
	"visualhostkey" => "VisualHostKey",
	"xauthlocation" => "XAuthLocation",
];
?>
<?php
/**
 * PSSH Config Object
 *  - manage config data
 *  - read/write ssh/json
 */
class PSSH_Config
{
	/**
	 * Map of keys to preferred case
	 */
	public static $CONFIG_KEYS = null;

    protected $data = null;

    protected $team_keys = null;
    protected $team_keys_identifier = null;

    protected $shell = null;

    protected $hosts_by_hostname = null;

    public function __construct($shell)
    {
        $this->shell = $shell;
    }

    /****************************************************************************************************
     * Primary methods
     ****************************************************************************************************/

    /**
     * Add host
     * @param $alias - alias for the host
     * @param $host - array of host info: ssh & pssh
     * @param $force - force add, generate unique host if needed
     * @return true if successful, false if failed
     * - If exact copy of host already is in this config, that counts as success
     * - On failure, host and alias are updated to prep for override
     */
    public function add(&$alias, &$host, $force=false)
    {
        $hostname = empty($host['ssh']['hostname']) ? null : $host['ssh']['hostname'];
        $user = empty($host['ssh']['user']) ? null : $host['ssh']['user'];

        $search = [
            'alias' => $alias,
            'hostname' => $hostname,
            'user' => $user,
        ];

        // Look up host in target by hostname & user
        $existing = $this->find($search);

        $existing_alias = $existing['alias'];

        $existing_config_aliases = [];
        $existing_config_alias = [];
        $existing_config = [];
        if (!is_null($hostname) and !is_null($user))
        {
            // should be only one, so let's just look at the first one
            $existing_config_aliases = array_keys($existing['hostname'][$user]);
            $existing_config_alias = array_shift($existing_config_aliases);
            $existing_config = array_shift($existing['hostname'][$user]);
        }

        $override_host = [];

        if (!empty($existing_config) and !$force)
        {
            // Remove info from config that's identical to existing
            $override_host = $this->host_diff($host, $existing_config);
            
            // New alias for same config?
            if (
                empty($override_host['pssh']['alias']) and
                empty($existing_alias[$alias])
            )
            {
                $override_host['pssh']['alias'] = $alias;
            }
            
        }
        else// no config match, or forcing override
        {

            $alias = $this->autoAlias($alias);

            $this->data['hosts'][$alias] = $host;

            return true;
        }

        if (empty($override_host))
        {
            return true;
        }

        $alias = $existing_config_alias;
        $host = $override_host;
        return false;
    }

    /**
     * Clean Up Data
     * - change hostnames to IP
     * - set up default alias
     * - set up default ssh key
     */
    public function clean()
    {
        $init = $this->initData();

		if (!empty($this->data['ssh']))
        {
            ksort($this->data['ssh']);
        }

        ksort($this->data['hosts']);

        $final_map = [];

        foreach ($this->data['hosts'] as $alias => &$host)
        {
            $hostname = empty($host['ssh']['hostname']) ? false : $host['ssh']['hostname'];

            // Set up alias
            if (empty($host['pssh']['alias']))
            {
                $host['pssh']['alias'] = $alias;
            }

            $pssh_alias = $host['pssh']['alias'];
            if (!isset($final_map[$pssh_alias]))
            {
                $final_map[$pssh_alias] = [];
            }

            $final_map[$pssh_alias][]= $alias;

            if (!empty($hostname))
            {
                $host['ssh']['hostname'] = $this->cleanHostname($host['ssh']['hostname'], $host['pssh']);
            }
        }

        foreach ($final_map as $final => $keys)
        {
            $c = count($keys);
            if ($c > 1)
            {
                $this->warn("$c hosts using alias '$final' - " . implode(", ", $keys));
            }
        }
    }

    /**
     * Find existing host by alias/hostname/user
     * @param $host - alias or array of data:
     *      [
     *          'alias' => $alias,
     *          'hostname' => $hostname,
     *          'user' => $user,
     *      ]
     *      NOTE: will only search user if IP is specified
     * @return array of host(s) that were found
     *  - indexed by what they matched (alias or hostname=>user)
     *  - each array will be empty if none found for that criteria
     *      [
     *          'alias' => [
     *              '<alias>' => $host
     *          ]
     *          'hostname' => [
     *              '<username>' => [
     *                  '<alias>' => $host
     *              ]
     *          ]
     *      ]
     */
    public function find($search)
    {
        // The info to search by
        $alias=null;
        $hostname=null;
        $user=null;

        $return = [
            'alias' => [],
            'hostname' => [],
        ];

        // String? Assume it's alias
        if (is_string($search))
        {
            $alias = $search;
        }

        // Parse out key values
        if (is_array($search))
        {
            $alias = empty($search['alias']) ? null : trim($search['alias']);
            $hostname = empty($search['hostname']) ? null : trim($search['hostname']);
            $user = empty($search['user']) ? null : trim($search['user']);
        }

        if (!empty($alias))
        {
            $return['alias'] = [$alias => $this->getHosts($alias)];
        }

        if (!empty($hostname))
        {
            $hosts = $this->getHostsByHostname($hostname);

            if (!empty($user))
            {
                $return['hostname'][$user] = [];
            }

            foreach($hosts as $alias => $host)
            {
                $_user = $host['ssh']['user'];
                if (empty($user) or $user == $_user)
                {
                    if (!isset($return['hostname'][$_user]))
                    {
                        $return['hostname'][$_user] = [];
                    }

                    $return['hostname'][$_user][$alias]= $host;
                }
            }
        }

        return $return;

    }

    /**
     * Get hosts by alias, or all
     * @param $alias - leave out to return all
     */
    public function getHosts($alias=null)
    {
        if (is_null($alias))
        {
            return empty($this->data['hosts']) ? [] : $this->data['hosts'];
        }

        return empty($this->data['hosts'][$alias]) ? [] : [$this->data['hosts'][$alias]];
    }

    /**
     * Delete hosts by alias
     * @param $alias
     */
    public function deleteHost($alias)
    {
        if (!empty($alias) and isset($this->data['hosts'][$alias]))
        {
            unset($this->data['hosts'][$alias]);
            return true;
        }

        return false;
    }

    /**
     * Set a host by alias with new data
     * @param $alias - to replace
     * @param $data - to replace with
     */
    public function setHost($alias, $data)
    {
        $this->data['hosts'][$alias] = $data;
    }

    /**
     * Get hosts by hostname, or full map
     * @param $hostname - leave out to return all
     */
    public function getHostsByHostname($hostname=null)
    {
        if (is_null($this->hosts_by_hostname))
        {
            $this->hosts_by_hostname = [];
            foreach ($this->getHosts() as $alias => $host)
            {
                if (empty($host['ssh']['hostname'])) continue;

                $_hostname = $host['ssh']['hostname'];
                if (!isset($this->hosts_by_hostname[$_hostname]))
                {
                    $this->hosts_by_hostname[$_hostname] = [];
                }
                $this->hosts_by_hostname[$_hostname][$alias]=$host;
            }
        }

        if (is_null($hostname))
        {
            return $this->hosts_by_hostname;
        }

        return empty($this->hosts_by_hostname[$hostname]) ? [] : $this->hosts_by_hostname[$hostname];
    }

    /**
     * Get team keys
     */
    public function getTeamKeys()
    {
        if (is_null($this->team_keys))
        {
            $this->team_keys = array();
            if (!empty($this->data['pssh']) and !empty($this->data['pssh']['team_keys']))
            {
                $raw = file_get_contents($this->data['pssh']['team_keys']);

                $data = $this->json_decode($raw, true);
                if ($data)
                {
                    $this->team_keys = $data;
                }
            }
        }
        return $this->team_keys;
    }

    /**
     * Get team keys identifier
     */
    public function getTeamKeysIdentifier()
    {
        if (is_null($this->team_keys_identifier))
        {
            $this->team_keys_identifier = 'team keys';
            if (!empty($this->data['pssh']) and !empty($this->data['pssh']['team_keys_identifier']))
            {
                $this->team_keys_identifier = $this->data['pssh']['team_keys_identifier'];
            }
        }
        return $this->team_keys_identifier;
    }

    /**
     * Recursively diff host info as though creating an override  
     * @param $host1 - Primary host - return this minus second
     * @param $host2 - Subtract info identical info in host2 from host1
     */
    public function host_diff($host1, $host2, $p="")
    {
        foreach ($host1 as $key => $value1)
        {
            // $this->log($p.$key);
            if (isset($host2[$key]))
            {
                $value2 = $host2[$key];

                if (is_array($value1) and is_array($value2))
                {
                    // $this->log($p.'RECUR');
                    $host1[$key] = $this->host_diff($value1, $value2, $p."-");
                    if (empty($host1[$key]))
                    {
                        // $this->log($p.'REMOVE');
                        unset($host1[$key]);
                    }
                }
                else
                {
                    if ($value1 == $value2)
                    {
                        // $this->log($p.'REMOVE');
                        unset($host1[$key]);
                    }
                }
            }
        }

        return $host1;
    }

    /**
     * Merge hosts into target
     * @param (PSSH_Config) $target - target of merge
     * @param (PSSH_Config) $override - overrides go here when conflicts arise
     */
    public function merge($target, $override)
    {
        $init = $this->initData();

        foreach ($this->getHosts() as $alias => $host)
        {
            $success = $target->add($alias, $host);
            if (!$success)
            {
                // force it into override file
                $override->add($alias, $host, true);
            }
        }
    }

    /**
     * Read from JSON path(s)
     * @param $paths - string or array of strings for multiple paths to read from
     */
    public function readJSON($paths)
    {
        $init = $this->initData();

        $paths = $this->prepArg($paths, []);

        $unmerged_data = [];

        // $this->log('Loading json files:');
        foreach ($paths as $path)
        {
            // $this->log(" - $path");

            if (!file_exists($path))
            {
                // $this->log(" --- file doesn't exist, will be created");
                continue;
            }

            $json = file_get_contents($path);

            $this->log("Decoding data from $path...");
            // $decoded = $this->json_decode($json, ['assoc' => true, 'keepWsc' => false]);
            $decoded = json_decode($json, true);
            if (empty($decoded))
            {
                $this->error("Likely Syntax Error: $path");
            }

            $unmerged_data[] = $decoded;
        }

        if (count($unmerged_data) == 1)
        {
            $this->data = $unmerged_data[0];
        }
        elseif (count($unmerged_data) > 1)
        {
            $this->data = call_user_func_array('array_replace_recursive', $unmerged_data);
        }
    }

    /**
     * Read from SSH path
     * @param $path - string path to read from
     */
    public function readSSH($path)
    {
		$path_handle = fopen($path, 'r');
        $init = $this->initData();

		$original_keys = [];

		$l = 0;
		while ($line = fgets($path_handle))
		{
			$l++;
			$line = trim($line);

			// $this->log("$l: $line");

            // Skip Blank Lines
            if (empty($line))
            {
				// $this->log(' - blank - skipping');
				continue;
            }

			// Skip Comments
			if (strpos($line,'#') === 0)
			{
				// $this->log(' - comment - skipping');
				continue;
			}

			// Parse into key and value
			if (preg_match('/^(\S+)\s+(.*)$/', $line, $match))
			{
				$key = strtolower($match[1]);
				$value = trim($match[2]);

                if (!isset(self::$CONFIG_KEYS[$key]))
                {
                    $original_keys[$key]= $match[1];
                }


				// $this->log(" - Parsed as [$key => $value]");
				if ($key == 'host')
				{
					$host = $value;
					$this->data['hosts'][$host] = [
						'ssh' => [],
						'pssh' => [],
					];
				}
				else
				{
					if (empty($host))
					{
						// $this->log(" - Determined to be general config");
						$this->data['ssh'][$key] = $value;
					}
					else
					{
						// $this->log(" - Adding to hosts[$host][ssh]");
						$this->data['hosts'][$host]['ssh'][$key] = $value;
					}
				}
			}
			else
			{
				$this->error("Unexpected syntax - check $path line $l");
			}
		}

        // Warn about any unknown keys our mapping didn't have
        if (!empty($original_keys))
        {
            $original_keys = array_unique($original_keys);
            sort($original_keys);
            $this->warn('Unknwon Config Key(s) Present - if these are valid, the PSSH code should be updated to know about them.');
            $this->output($original_keys);
        }

		fclose($path_handle);
    }

    /**
     * Search - search for host config by:
     *  - host alias
     *  - domain or IP
     *  - username
     * @param $termstring - search string
     *  - separate terms with spaces
     */
    public function search($termstring)
    {
        $termstring = strtolower(trim($termstring));

        // No search - return all hosts
        if(empty($termstring))
        {
            return $this->data['hosts'];
        }

        $terms = explode(" ", $termstring);
        $terms = array_map('trim', $terms);
        $ips = [];
        foreach($terms as $term)
        {
            $ip = $this->cleanHostname($term, [], false);

            if ($ip != $term)
            {
                $ips[]= $ip;
            }
        }

        $terms = array_merge($terms, $ips);

        $terms_pattern = "(".implode("|", $terms).")";

        // Patterns for search, keyed by levity
        $patterns = [
            4 => "\b$termstring\b",
            3 => "$termstring",
            2 => "\b4$terms_pattern\b",
            1 => "$terms_pattern",
        ];

        $h=0;
        $results = [];

        foreach ($this->data['hosts'] as $alias => $host)
        {
            // Higher levity will float higher in results
            // 0 = no match - falls out of the list
            $levity = 0;

            // Targets for search, keyed by levity
            // - below expect less than 10 targets
            $targets = [
                4 => @$host['pssh']['alias'],
                3 => @$host['ssh']['hostname'],
                2 => @$host['ssh']['user'],
                1 => $alias,
            ];

            if (empty($host['pssh']['alias']))
            {
                $host['pssh']['alias'] = $alias;
            }


            foreach($targets as $t => $target)
            {
                foreach ($patterns as $p => $pattern)
                {
                    if (preg_match_all("`" . $pattern . "`", $target, $matches))
                    {
                        $levity+= ( ($p+1) * 10)  + ($t+1);
                        continue; //quit as soon as we have a match
                    }
                }
            }

            if ($levity > 0)
            {
                $this->log("$alias: $levity");

                // Multiply to make sure host index doesn't matter much beyond ensuring uniqueness
                // - we are making the bold assumption that there are less than 1 billion host entries
                $levity = ($levity * 1000000000) + $h;

                $results[$levity] = [$alias, $host];
            }
            
            $h++;
        }

        krsort($results);

        // Re-key by alias
        $return = [];
        foreach ($results as $result)
        {
            $alias = $result[0];
            $host = $result[1];
            $return[$alias] = $host;
        }

        return $return;
    }

    /**
     * Write to JSON path
     * @param $path - string path to write to
     */
    public function writeJSON($path)
    {
        /*
        if (preg_match("/.hjson$/", $path))
        {
            $json = $this->json_encode($this->data);
        }
        else
        {
         */
            $json = json_encode($this->data, JSON_PRETTY_PRINT);
        //}
		file_put_contents($path, $json);
    }

    /**
     * Write to SSH path
     * @param $path - string path to read to
     */
    public function writeSSH($path)
    {
		$path_handle = fopen($path, 'w');

        // $this->log("Outputting Comment");
        fwrite($path_handle, "# ---------------------------------------\n");
        fwrite($path_handle, "# Generated by PSSH - {$this->stamp()}\n");
        fwrite($path_handle, "#   - DO NOT EDIT THIS FILE, USE PSSH\n");
        fwrite($path_handle, "# ---------------------------------------\n");

        // $this->log("Outputting General Config");
        fwrite($path_handle, "\n");
        fwrite($path_handle, "# ---------------------------------------\n");
        fwrite($path_handle, "# General Config\n");
        fwrite($path_handle, "# ---------------------------------------\n");
        if (!empty($this->data['ssh']))
        {
			foreach ($this->data['ssh'] as $key => $value)
			{
				// $this->log(" - $key: $value");
				$Key = isset(self::$CONFIG_KEYS[$key]) ? self::$CONFIG_KEYS[$key] : ucwords($key);
				fwrite($path_handle, $Key . ' ' . $value . "\n");
			}
        }

        // $this->log("Outputting Hosts Config");
        fwrite($path_handle, "\n");
        fwrite($path_handle, "# ---------------------------------------\n");
        fwrite($path_handle, "# HOSTS\n");
        fwrite($path_handle, "# ---------------------------------------\n");
        foreach ($this->getHosts() as $alias => $host_config)
        {
            if (empty($host_config['pssh']['alias']))
            {
                $host_config['pssh']['alias'] = $alias;
            }

            $host_output = $this->writeSSHHost($host_config);
            fwrite($path_handle, $host_output);
        }

        // $this->log("Outputting Vim Syntax Comment");
        fwrite($path_handle, "\n# vim: syntax=sshconfig");

		fclose($path_handle);
    }

    /**
     * Convert host data to SSH format
     * @param $host - host data to convert
     **/
    public function writeSSHHost($host)
    {
        $output = "";
        $output.='Host ' . $host['pssh']['alias'] . "\n";
        foreach ($host['ssh'] as $key => $value)
        {
            $Key = isset(self::$CONFIG_KEYS[$key]) ? self::$CONFIG_KEYS[$key] : ucwords($key);
            $output.= '    ' . $Key . ' ' . $value . "\n";
        }
        return $output;
    }

    /****************************************************************************************************
     * Secondary/Helper Methods
     ****************************************************************************************************/

    /**
     * Initialize data
     *  - return true if it was empty (null)
     *  - return false if it was not
     */
    public function initData()
    {
        if (is_null($this->data))
        {
            $this->data = [
                "ssh" => [],
                "pssh" => [],
                "hosts" => [],
            ];
            return true;
        }

        return false;// no init was needed
    }

    /**
     * Make sure alias is unique, add 1/2/3, etc as needed to ensure
     */
    public function autoAlias($alias)
    {
        $i=0;
        $new_alias = $alias;
        while (isset($this->data['hosts'][$new_alias]))
        {
            $i++;
            $new_alias = $alias.$i;
        }

        return $new_alias;
    }

    /**
     * Clean hostname, lookup IP if needed
     * @param $hostname - domain/ip to clean
     * @param $pssh - config of host to check for settings
     * @param $certain - whether we're certain the hostname is intended to be a hostname
     *  If certain, we'll warn if we can't look it up
     *  If uncertain, we'll validate it as a URL before looking up
     */
    public function cleanHostname($hostname, $pssh=[], $certain=true)
    {
        // $this->log("cleanHostname($hostname, ..., $certain)");

        // Make sure lookup isn't disabled by pssh config
        $lookup = (
            !is_array($pssh)
            or !isset($pssh['lookup'])
            or strtolower($pssh['lookup']) != 'no'
        );

        $valid_ip = filter_var($hostname, FILTER_VALIDATE_IP);
        $valid_url = filter_var('http://'.$hostname, FILTER_VALIDATE_URL);

        // Canonicalize to IP Address
        if (
            // Not empty, and not specifically instructed against lookup
            !empty($hostname) and $lookup
            // It's not already an IP
            and !$valid_ip
            // Either we're certain it's a hostname
            // or it looks like a URL
            and ($certain or $valid_url)
        ) {
            // $this->log("Looking up $hostname");
            $info = @dns_get_record($hostname, DNS_A);
            if (
                empty($info)
                or empty($info[0]['ip'])
                or !filter_var($info[0]['ip'], FILTER_VALIDATE_IP)
            ){
                if ($certain)
                {
                    $this->warn("Failed lookup - $hostname.  Set pssh:lookup to 'no' if this is normal for this host.");
                }
                return $hostname;
            }

            $ip = $info[0]['ip'];

            if (filter_var($ip, FILTER_VALIDATE_IP))
            {
                $hostname = $ip;
            }
        }
        else
        {
            // $this->log("Hostname Approved ($hostname)");
        }

        return $hostname;
    }

    /**
     * Pass through functions for shell
     */
    public function __call($method, $arguments)
    {
        $shell_call = [$this->shell, $method];
        if (is_callable($shell_call))
        {
            $this->shell->log(" __call: Attempting to call $method on separate class...");
            return call_user_func_array($shell_call, $arguments);
        }
    }
}
PSSH_Config::$CONFIG_KEYS=$CONFIG_KEYS;
?>
<?php
/**
 * PSSH Console Interface
 */
class PSSH extends Console_Abstract
{
    const VERSION = "2.3.0";

    // Name of script and directory to store config
    const SHORTNAME = 'pssh';

    /**
     * Callable Methods
     */
    protected static $METHODS = [
        'add',
        'clean',
        'edit_host',
        'delete_host',
        'export',
        'import',
        'init_host',
        'list',
        'merge',
        'search',
        'sync',
    ];

    protected static $HIDDEN_CONFIG_OPTIONS = [
        'json_config_paths',
        'json_import_path',
        'ssh_config_path',
        'sync',
    ];

    // Config Variables
    protected $__json_config_paths = ["Main JSON config file paths - first one will be synced by default, others will be ignored by default", "string"];
    public $json_config_paths = [];

    protected $__json_import_path = ["Default JSON config import path", "string"];
    public $json_import_path = null;

    protected $__ssh_config_path = ["Default SSH config path", "string"];
    public $ssh_config_path = null;

    protected $__cli_script = ["CLI script to install on hosts during init", "string"];
    public $cli_script = '';

    protected $__sync = ["Git SSH URL to sync config data", "string"];
    public $sync = '';

	public $update_version_url = "https://raw.githubusercontent.com/chrisputnam9/pssh/master/README.md";

    protected $___add = [
        "Add new SSH host - interactive, or specify options",
        ["JSON file to add host to", "string"],
        ["Hostname - domain or IP", "string"],
        ["Username", "string"],
        ["Alias", "string"],
        ["Port", "integer"],
    ];
	public function add($target=null, $hostname=null, $user=null, $alias=null, $port=null)
    {

        // Sync before - to get latest data
        $this->sync();

        $config = new PSSH_Config($this);

        $this->hr();
        $this->output('ADDING SSH HOST');
        $this->hr();

        // Determine file to write to
        if (is_null($target))
        {
            $target = $this->select($this->json_config_paths, 'Config File');
        }
        $config->readJson($target);

        // Hostname
        if (is_null($hostname))
        {
            $hostname = $this->input('HostName (URL/IP)', null, true);
        }
        else
        {
            $this->output("HostName (URL/IP): $hostname");
        }
        $clean_hostname = $config->cleanHostname($hostname);
        if ($clean_hostname != $hostname)
        {
            $hostname = $clean_hostname;
            $this->output(" ($hostname)");
        }

        // User Name
        if (is_null($user))
        {
            $existing = $config->find(['hostname'=>$hostname]);
            $existing_users = array_keys($existing['hostname']);
            if (!empty($existing_users))
            {
                $this->output("NOTE: existing users configured for this hostname: (" . join(", ", $existing_users) . ")");
            }
            $user = $this->input('User', null, true);
        }
        else
        {
            $this->output("User: $user");
        }

        // Host Alias
        if (is_null($alias))
        {
            $default = $config->autoAlias($user);
            $alias = $this->input('Alias', $default);
        }
        else
        {
            $this->output("Alias: $alias");
        }

        // Port
        if (is_null($port))
        {
            // for specified hostname
            $port = $this->input('Port', 22);
        }
        else
        {
            $this->output("Port: $port");
        }

        $this->hr();
        $this->output("- adding host to $target...");

        $host = [
            'ssh' => [
                'user' => $user,
                'hostname' => $hostname,
                'port' => $port,
            ],
        ];
        $success = $config->add($alias, $host);

        // Any error? For now, just quitting
        if (!$success)
        {
            $this->hr();
            $this->error("Unable to add host - likely conflict in $target");
        }


        // Backup, clean, save json
        $this->backup($target);
        $config->clean();
        $config->writeJson($target);

        // write out ssh config
        $this->export();

        $this->sync();

        // Initialize Host (prompt - key, cli)
        $this->init_host($alias, null, null, $target, null);

        $this->hr();
        $this->output('Done!');
    }

    protected $___clean = [
        "Clean json config files",
        ["JSON file(s) to clean - defaults to json-config-paths", "string"],
    ];
    public function clean($paths=null)
    {
        $paths = $this->prepArg($paths, $this->json_config_paths);

        $this->log("Cleaning config files:");
        $this->log($paths);

        $this->log("Backing up...");
        $this->backup($paths);

        foreach ($paths as $path)
        {
            $this->log("Cleaning '$path'");
            $config = new PSSH_Config($this);
            $config->readJSON($path);
            $config->clean();
            $config->writeJSON($path);
        }

        $this->output('Clean complete');
    }

    protected $___export = [
        "Export JSON config to SSH config file",
        ["Source JSON files - defaults to json-config-paths", "string"],
        ["Target SSH config file - defaults to ssh-config-path", "string"],
    ];
	public function export($sources=[], $target=null)
	{
        $target = $this->prepArg($target, $this->ssh_config_path);
        $sources = $this->prepArg($sources, $this->json_config_paths);

        $this->backup($target);

        $config = new PSSH_Config($this);
        $config->readJSON($sources);
        $config->clean();
        $config->writeSSH($target);

        $this->output('Export complete');
    }

    protected $___import = [
        "Import SSH config data into JSON",
        ["Target JSON file - defaults to json-import-path", "string"],
        ["Source SSH config file - defaults to ssh-config-path"],
    ];
	public function import($target=null, $source=null)
	{
        // Defaults
        $target = $this->prepArg($target, $this->json_import_path);
        $source = $this->prepArg($source, $this->ssh_config_path);

        if (is_file($target))
        {
            $this->backup($target);
        }

        $config = new PSSH_Config($this);
        $config->readSSH($source);
        $config->clean();
        $config->writeJSON($target);

        $this->output('Import complete - see json in ' . $target);
	}

    protected $___delete_host = [
        "Delete host",
        ["Alias of host to delete", "string", "required"],
        ["Specific JSON file(s) to delete from - defaults to delete from ALL files in json-config-paths", "string"],
    ];
    public function delete_host($alias, $paths=null) {

        $paths = $this->prepArg($paths, $this->json_config_paths);
        
        // Sync before - to get latest data
        $this->sync();

        $host_json = false;

        foreach ($paths as $config_path)
        {
            $config = new PSSH_Config($this);
            $config->readJSON($config_path);

            if ($config->deleteHost($alias))
            {
                // Backup, clean, save json
                $this->backup($config_path);
                $config->clean();
                $config->writeJson($config_path);
            }
        }

        // write out ssh config
        $this->export();

        $this->sync();

        $this->hr();
        $this->output('Done!');
        return true;
    }

    protected $___edit_host = [
        "Edit host - modify config in your editor",
        ["Alias of host", "string", "required"],
        ["Specific JSON file(s) to edit - defaults to first found in json-config-paths that contains the host alias", "string"],
    ];
    public function edit_host($alias, $paths=null) {
        $paths = $this->prepArg($paths, $this->json_config_paths);
        
        // Sync before - to get latest data
        $this->sync();

        $host_json = false;

        foreach ($paths as $config_path)
        {
            $config = new PSSH_Config($this);
            $config->readJSON($config_path);
            $host_data = $config->getHosts($alias);
            if (!empty($host_data) and !empty($host_data[0]))
            {
                $host_data = $host_data[0];
                $host_json = json_encode($host_data, JSON_PRETTY_PRINT);
                break;
            }
        }

        if (empty($host_json))
        {
            $this->error("Host '$alias' not found in config files");
        }

        $original_json = $host_json;

        while (true)
        {
            $host_json = $this->edit($host_json, $alias . ".json", "modify");
            $host_data = $this->json_decode($host_json, ['assoc' => true, 'keepWsc' => false]);
            if (empty($host_data))
            {
                $this->warn("Invalid JSON - check your syntax");
                $continue = $this->confirm("Keep editing?");
                if ( ! $continue )
                {
                    return false;
                }
            }
            else
            {
                break;
            }
        }

        // Test for actual changes
        $host_json = json_encode($host_data, JSON_PRETTY_PRINT);
        if ($host_json == $original_json)
        {
            // No actual change, no need to update
            return false;
        }

        $config->setHost($alias, $host_data);

        // Backup, clean, save json
        $this->backup($config_path);
        $config->clean();

        $config->writeJson($config_path);

        // write out ssh config
        $this->export();

        $this->sync();

        $this->hr();
        $this->output('Done!');
        return true;
    }

    protected $___init_host = [
        "Initialize host - interactive, or specify options",
        ["Alias of host", "string", "required"],
        ["Copy your SSH key to the server", "boolean"],
        ["Copy all team SSH keys to the server - if set", "boolean"],
        ["JSON file for team key data", "string"],
        ["Set up server CLI using cli_script", "boolean"],
    ];
    public function init_host($alias, $copy_key=null, $copy_team_keys=null, $team_config=null, $cli=null) {

        // Copy Key?
        if (is_null($copy_key))
        {
            $copy_key = $this->confirm('Copy Key?');
        }
        if ($copy_key or $copy_team_keys)
        {
            if (is_null($copy_team_keys))
            {
                $copy_team_keys = $this->confirm('Copy all team keys?', 'n');
            }

            if ($copy_team_keys)
            {
                $config = new PSSH_Config($this);
                if (is_null($team_config))
                {
                    $team_config = $this->select($this->json_config_paths, 'Config for team keys');
                }
                $config->readJson($team_config);

                $identifier = $config->getTeamKeysIdentifier();
                $team_keys = $config->getTeamKeys();
                if (empty($team_keys))
                {
                    $this->warn('No team key config found, copying your key instead');
                }
            }

            $this->output('Enter ssh password for this host if prompted');

            if ($copy_team_keys)
            {
                $config = <<<____KEYS____
# ----------------------------------
# BEGIN - {$identifier}

____KEYS____;
                foreach ($team_keys as $team => $users)
                {
                    foreach ($users as $name => $user)
                    {
                        foreach ($user['keys'] as $key)
                        {
                            $config.=$key['key'] . "\n";
                        }
                    }
                }

                $config.= <<<____KEYS____
# END - {$identifier}
# ----------------------------------
____KEYS____;
                $this->exec("ssh $alias 'mkdir -p ~/.ssh && echo \"".$config."\" >> ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys'");
            }
            else
            {
                $this->exec("ssh-copy-id $alias");
            }
        }

        // Set up Custom CLI Tools?
        if (is_null($cli) and !empty($this->cli_script) and is_file($this->cli_script))
        {
            $cli = $this->confirm('Set up server cli tools?');
        }
        if ($cli)
        {
            $this->exec("bash {$this->cli_script} $alias");
        }

    }

    protected $___merge = [
        "Merge config from one JSON file into another",
        ["JSON file to merge from", "string", "required"],
        ["JSON file to merge into", "string", "required"],
        ["JSON file to ouput conflicts/overrides", "string", "required"],
    ];
    public function merge($source_path, $target_path, $override_path)
    {
        $this->backup($target_path);
        $this->backup($override_path);

        $this->output("Merging config...");
        $source = new PSSH_Config($this);
        $source->readJSON($source_path);

        $target = new PSSH_Config($this);
        $target->readJSON($target_path);

        $override = new PSSH_Config($this);
        $override->readJSON($override_path);

        $source->merge($target, $override);

        $target->clean();
        $target->writeJSON($target_path);

        $override->clean();
        $override->writeJSON($override_path);

        $this->output("Merge complete");
    }

    protected $___search = [
        "Search for host configuration",
        ["Term(s) to search - separate with spaces", "string", "required"],
        ["JSON config path(s) to search - defaults to json-config-paths", "string"],
    ];
    public function search($terms, $paths=null)
    {
        $paths = $this->prepArg($paths, $this->json_config_paths);

        $this->log("Searching config files:");
        $this->log($paths);

        $config = new PSSH_Config($this);
        $config->readJSON($paths);

        $results = $config->search($terms);

        if (empty($results))
        {
            $this->output("No results found");
        }
        else
        {
            $list = new Command_Visual_List($this, $results,
                [
                    'template' => "{pssh:alias|%-'.30s} {ssh:user}{ssh:hostname|@%s}{ssh:port|:%s}",
                    'reload_function' => function ($reload_data) {
                        $config = new PSSH_Config($this);
                        $config->readJSON($reload_data['paths']);
                        return $config->search($reload_data['terms']);
                    },
                    'reload_data' => [
                        'paths' => $paths,
                        'terms' => $terms,
                    ],
                    'commands' => [
                        'init_host' => [
                            'description' => 'Initialize the focused host',
                            'keys' => 'i',
                            'callback' => function ($list_instance)
                            {
                                $focused_key = $list_instance->getFocusedKey();
                                $this->init_host($focused_key);
                            },
                        ],
                        'delete_host' => [
                            'description' => 'Delete the focused host',
                            'keys' => 'd',
                            'callback' => function ($list_instance)
                            {
                                $focused_key = $list_instance->getFocusedKey();
                                $host_alias = $focused_key;
                                if ($this->confirm("Are you sure you want to delete the config for '$host_alias'?", "n"))
                                {
                                    $this->delete_host($host_alias);
                                }
                            },
                            'reload' => true,
                        ],
                        'edit_host' => [
                            'description' => 'Edit the focused host',
                            'keys' => 'e',
                            'callback' => function ($list_instance)
                            {
                                $focused_key = $list_instance->getFocusedKey();
                                $this->edit_host($focused_key);
                            },
                            'reload' => true,
                        ],
                    ],
                ]
            ); 
            $list->run();
        }
    }

    protected $___list = [
        "List all hosts",
        ["JSON config path(s) to list - defaults to json-config-paths", "string"],
    ];
    public function list($paths=null)
    {
        $this->search($paths);
    }

    /**
     * Currently only supports private git repository
     */
    protected $___sync = "Sync config files based on 'sync' config/option value";
    public function sync()
    {
        if (empty($this->sync)) return;

        $this->output('Syncing...');

        if (substr($this->sync, 0, 4) == 'git@')
        {
            // Temporarily switch to config_dir
            $original_dir = getcwd();
            chdir($this->config_dir);

            // Set up git if not already done
            if (!is_dir($this->config_dir . DS . '.git'))
            {
                // $this->log('Running commands to initialize git');
                $this->exec("git init");
                $this->exec("git remote add sync {$this->sync}");
            }

            // Pull
            // $this->log('Pulling from remote (sync)');
            $this->exec("git pull sync master");

            // Set up git ignore if not already there
            if (!is_file($this->config_dir . DS . '.gitignore'))
            {
                // $this->log('Setting up default ignore file');
                $synced_config_json = empty($this->json_config_paths)
                    ? ''
                    : '!' . str_replace($this->config_dir, "", array_shift($this->json_config_paths));
                $ignore = <<<GITGNORE
*
!.gitignore
!ssh_cli.sh
{$synced_config_json}
GITGNORE;
                file_put_contents($this->config_dir . DS . '.gitignore', $ignore);
            }

            // Push
            // $this->log('Committing and pushing to remote (sync)');
            $this->exec("git add . --all");
            $this->exec("git commit -m \"Automatic sync commit - {$this->stamp()}\"");
            $this->exec("git push sync master");

            // Switch back to original directory
            chdir($original_dir);
        }
    }

    /**
     * Init config defaults, then call parent
     */
    public function initConfig()
    {
        $config_dir = $this->getConfigDir();

        // Config defaults
        $this->json_config_paths = [
            $config_dir . DS . 'ssh_config_work.json',
            $config_dir . DS . 'ssh_config_personal.json',
        ];
        $this->json_import_path = $config_dir . DS . 'ssh_config_imported.json';

        $this->ssh_config_path = $_SERVER['HOME'] . DS . '.ssh' . DS . 'config';

        $cli_script = $config_dir . DS . 'ssh_cli.sh';
        if (is_file($cli_script))
        {
            $this->cli_script = $cli_script;
        }

        parent::initConfig();
    }
}
PSSH::run($argv);
?>
